{"meta":{"title":"Footprints of Growth","subtitle":"Note when going straight for success of Mr.Wang","description":"To be or not to be, that is a question.","author":"Mr.Wang","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2019-12-18T08:21:21.000Z","updated":"2019-12-18T08:24:21.258Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-18T08:28:30.000Z","updated":"2019-12-18T08:30:44.633Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"单例模式","slug":"singleton-pattern","date":"2019-12-25T03:22:36.000Z","updated":"2019-12-25T10:51:01.538Z","comments":true,"path":"2019/12/25/singleton-pattern/","link":"","permalink":"http://yoursite.com/2019/12/25/singleton-pattern/","excerpt":"设计模式之单例模式定义&emsp;&emsp;单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。","text":"设计模式之单例模式定义&emsp;&emsp;单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 了解&emsp;&emsp;单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 结构图单例模式是结构最简单的设计模式一，在它的核心结构中只包含一个被称为单例类的特殊类Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 示例 饿汉式单例与懒汉式单例饿汉式12345678class EagerSingleton &#123; private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125; &#125; &emsp;&emsp;当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。 懒汉式&emsp;&emsp;懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术避免多线程环境下出现问题（实例化多个对象）: synchronized关键字：可加在类上，也可加在判空后的初始化对象方法上，后者效率更高 双重检查锁定(Double-Check Locking) volatile修饰符：被volatile修饰的成员变量可以确保多个线程都能够正确处理，但volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低 12345678910111213141516171819class LazySingleton &#123; private volatile static LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; //第一重判断 if (instance == null) &#123; //锁定代码块 synchronized (LazySingleton.class) &#123; //第二重判断 if (instance == null) &#123; instance = new LazySingleton(); //创建单例实例 &#125; &#125; &#125; return instance; &#125;&#125; 比较 &emsp;&emsp;饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 &emsp;&emsp;懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。 Initialization Demand Holder (IoDH)1234567891011121314151617181920//Initialization on Demand Holderclass Singleton &#123; private Singleton() &#123; &#125; private static class HolderClass &#123; private final static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return HolderClass.instance; &#125; public static void main(String args[]) &#123; Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); System.out.println(s1==s2); &#125;&#125; &emsp;&emsp;在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用&emsp;&emsp;由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。&emsp;&emsp;通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式，但是其与编程语言本身的特性相关，很多面向对象语言不支持IoDH。 总结&emsp;&emsp;单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。 优点 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。 缺点 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。 适用场景 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import javax.xml.crypto.dsig.spec.DigestMethodParameterSpec;import java.util.*;/** * @author Wangzy * @Description: 负载均衡器 * @date 17:01 2019/12/25 */public class LoadBalancer &#123; // 饿汉式单例模式// private static final LoadBalancer loadBalancer = new LoadBalancer(); /** * @Description: （懒汉式单例模式）静态变量引用 volatile 关键字保证确保多个线程都能够正确处理，但volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低 * @author Wangzy * @date 17:53 2019/12/25 */// private volatile static LoadBalancer loadBalancer = null; /** 各个服务器集合 */ private List&lt;String&gt; serverList; /** * @Description: 私有构造方法 * @author Wangzy * @date 17:02 2019/12/25 */ private LoadBalancer() &#123; // 默认负载均衡器自带服务器容器 serverList = new ArrayList&lt;&gt;(); &#125; /** * @Description: 提供整个系统的实例化对象方法 加锁和双重检查锁定都是为了解决多线程产生的问题 * @author Wangzy * @date 17:04 2019/12/25 */// public static LoadBalancer getInstance() &#123;//// if (null == loadBalancer) &#123;//// // 加锁//// synchronized (LoadBalancer.class) &#123;//// // 双重检查锁定//// if (null == loadBalancer) &#123;//// loadBalancer = new LoadBalancer();//// &#125;//// &#125;//// &#125;//// return loadBalancer;//// &#125; /** * @Description: IoDH 要实例化的类不会加载此类；jvm会自动优化线程问题；效率最高，但受语言限制 * @author Wangzy * @date 18:05 2019/12/25 */ private static class ClassHolder &#123; private static final LoadBalancer loadBalancer = new LoadBalancer(); &#125; public static LoadBalancer getInstance() &#123; return ClassHolder.loadBalancer; &#125; /** * @Description: 添加服务器 * @author Wangzy * @date 17:06 2019/12/25 */ public void addServer(String server) &#123; serverList.add(server); &#125; /** * @Description: 移除服务器 * @author Wangzy * @date 17:06 2019/12/25 */ public void removeServer(String server) &#123; serverList.remove(server); &#125; /** * @Description: 查询服务器(负载均衡实现，随机算法) * @author Wangzy * @date 17:06 2019/12/25 */ public String getServer() &#123; List&lt;String&gt; serverList = this.serverList; Random random = new Random(); int i = random.nextInt(serverList.size()); return serverList.get(i); &#125;&#125; 123456789101112131415161718192021222324252627/** * @author Wangzy * @Description: 启动类 * @date 17:12 2019/12/25 */public class Boot &#123; public static void main(String[] args) &#123; // 获取负载均衡服务器（模拟多个用户共享一个实例） LoadBalancer loadBalancer = LoadBalancer.getInstance(); LoadBalancer loadBalancer1 = LoadBalancer.getInstance(); LoadBalancer loadBalancer2 = LoadBalancer.getInstance(); // 判断是否是同一个负载均衡器(是否获取的是同一个实例) if (loadBalancer == loadBalancer1 &amp;&amp; loadBalancer1 == loadBalancer2) &#123; System.out.println(\"服务器负载均衡器具有唯一性！\"); &#125; // 给负载均衡服务器添加服务器 loadBalancer.addServer(\"server1\"); loadBalancer.addServer(\"server2\"); loadBalancer.addServer(\"server3\"); // 模拟客户端请求分发 for (int i = 1; i &lt; 10; i++) &#123; System.out.println(\"分发请求至服务器\" + loadBalancer.getServer() + \"服务器!\"); &#125; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7420883https://blog.csdn.net/lovelion/article/details/7420885https://blog.csdn.net/lovelion/article/details/9319423https://blog.csdn.net/lovelion/article/details/7420888https://blog.csdn.net/lovelion/article/details/7420889","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"抽象工厂模式","slug":"abstract-factory","date":"2019-12-25T03:22:35.000Z","updated":"2019-12-25T10:19:51.511Z","comments":true,"path":"2019/12/25/abstract-factory/","link":"","permalink":"http://yoursite.com/2019/12/25/abstract-factory/","excerpt":"设计模式之抽象工厂模式产品等级结构与产品族&emsp;&emsp;工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。先引入两个概念： 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 定义&emsp;&emsp;抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。","text":"设计模式之抽象工厂模式产品等级结构与产品族&emsp;&emsp;工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。先引入两个概念： 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 定义&emsp;&emsp;抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。 了解&emsp;&emsp;当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。 &emsp;&emsp;在上图中可以发现，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，上图所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减少了系统中类的个数。 结构图在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族 AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 重载的工厂方法&emsp;&emsp;与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式对产品对象进行创建。 示例 如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件即可使用新的皮肤，原有代码无须修改，符合“开闭原则” 开闭原则的倾斜性&emsp;&emsp;在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。&emsp;&emsp;正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。 总结&emsp;&emsp;抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。 优点1.抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。 适用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 code123456789101112131415161718192021import javafx.scene.control.Skin;/** * @author Wangzy * @Description: 启动类 * @date 17:45 2019/12/12 */public class Boot &#123; public static void main(String[] args) &#123;// SkinFactory skinFactory = new SpringSkinFactory(); // 通过配置文件方式实现符合“开闭原则”的代码 SkinFactory skinFactory = (SkinFactory) XMLUtil.getBean(); Button button = skinFactory.createButton(); TextField textField = skinFactory.createTextField(); ComboBox comboBox = skinFactory.createComboBox(); button.display(); textField.display(); comboBox.display(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @author Wangzy * @Description: 按钮产品抽象类 * @date 17:32 2019/12/12 */public interface Button &#123; /** * @Description: 显示 * @author Wangzy * @date 17:33 2019/12/12 */ void display();&#125;/** * @author Wangzy * @Description: 复合文本框产品抽象类 * @date 17:34 2019/12/12 */public interface ComboBox &#123; /** * @Description: 显示 * @author Wangzy * @date 17:35 2019/12/12 */ void display();&#125;/** * @author Wangzy * @Description: 文本框产品抽象类 * @date 17:33 2019/12/12 */public interface TextField &#123; /** * @Description: 显示 * @author Wangzy * @date 17:34 2019/12/12 */ void display();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @author Wangzy * @Description: 春天按钮 * @date 17:39 2019/12/12 */public class SpringButton implements Button &#123; @Override public void display() &#123; System.out.println(\"spring button display！\"); &#125;&#125;/** * @author Wangzy * @Description: 春天复合文本框 * @date 17:40 2019/12/12 */public class SpringComboBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"spring combobox display！\"); &#125;&#125;/** * @author Wangzy * @Description: 春天文本框 * @date 17:39 2019/12/12 */public class SpringTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"spring textfield display！\"); &#125;&#125;/** * @author Wangzy * @Description: 夏天按钮 * @date 17:39 2019/12/12 */public class SummerButton implements Button &#123; @Override public void display() &#123; System.out.println(\"summer button display！\"); &#125;&#125;/** * @author Wangzy * @Description: 夏天复合文本框 * @date 17:40 2019/12/12 */public class SummerComboBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"summer combobox display！\"); &#125;&#125;/** * @author Wangzy * @Description: 夏天文本框 * @date 17:39 2019/12/12 */public class SummerTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"summer textfield display！\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author Wangzy * @Description: 春天界面工厂 * @date 17:36 2019/12/12 */public class SpringSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; System.out.println(\"create spring button！\"); return new SpringButton(); &#125; @Override public TextField createTextField() &#123; System.out.println(\"create spring textfield！\"); return new SpringTextField(); &#125; @Override public ComboBox createComboBox() &#123; System.out.println(\"create spring combobox！\"); return new SpringComboBox(); &#125;&#125;/** * @author Wangzy * @Description: 夏天风格产品工厂 * @date 17:42 2019/12/12 */public class SummerSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; System.out.println(\"create summer button！\"); return new SummerButton(); &#125; @Override public TextField createTextField() &#123; System.out.println(\"create summer textfield！\"); return new SummerTextField(); &#125; @Override public ComboBox createComboBox() &#123; System.out.println(\"create summer combobox！\"); return new SummerComboBox(); &#125;&#125; 12345678910111213141516171819202122232425262728/** * @author Wangzy * @Description: 抽象界面工厂 * @date 17:28 2019/12/12 */public interface SkinFactory &#123; /** * @Description: 创建按钮 * @author Wangzy * @date 17:30 2019/12/12 */ Button createButton(); /** * @Description: 创建文本框 * @author Wangzy * @date 17:30 2019/12/12 */ TextField createTextField(); /** * @Description: 创建复合文本框 * @author Wangzy * @date 17:31 2019/12/12 */ ComboBox createComboBox();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.xml.parsers.*;import org.w3c.dom.*;import org.xml.sax.SAXException;import java.io.*;/** * @author Wangzy * @Description: xml工具类 * @date 17:49 2019/12/12 */public class XMLUtil &#123; /** * @Description: 该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 * @author Wangzy * @date 17:50 2019/12/12 */ public static Object getBean() &#123; try &#123; // 创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\"src/config.xml\")); // 获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(\"className\"); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234&lt;?xml version=\"1.0\"?&gt;&lt;config&gt; &lt;className&gt;SpringSkinFactory&lt;/className&gt;&lt;/config&gt; 相关资料https://blog.csdn.net/lovelion/article/details/9319181https://blog.csdn.net/lovelion/article/details/9319323https://blog.csdn.net/lovelion/article/details/9319423https://blog.csdn.net/lovelion/article/details/9319481https://blog.csdn.net/lovelion/article/details/9319571","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"工厂方法模式","slug":"factory-methos","date":"2019-12-25T03:22:34.000Z","updated":"2019-12-25T07:11:47.504Z","comments":true,"path":"2019/12/25/factory-methos/","link":"","permalink":"http://yoursite.com/2019/12/25/factory-methos/","excerpt":"设计模式之工厂方法模式定义&emsp;&emsp;工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 了解&emsp;&emsp;在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。","text":"设计模式之工厂方法模式定义&emsp;&emsp;工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 了解&emsp;&emsp;在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。 结构图工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。 Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。 ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 示例 重载的工厂方法&emsp;&emsp;在抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。当然，对于同一个具体工厂而言，无论使用哪个工厂方法，创建的产品类型均要相同。 example: 工厂方法的隐藏&emsp;&emsp;有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。 总结&emsp;&emsp;工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。 优点 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 适用场景 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 code12345678910111213141516171819/** * @author Wangzy * @Description: 启动类 * @date 15:52 2019/12/12 */public class Boot &#123; public static void main(String[] args) &#123; // 获取工厂// LoggerFactory factory = new DatebaseLoggerFactory();// LoggerFactory factory = new FileLoggerFactory();// Logger logger = factory.createLogger();// logger.writeLogger(); // 读取配置文件生成类 LoggerFactory factory = (LoggerFactory) XMLUtil.getBean(); Logger logger = factory.createLogger(); logger.writeLogger(); &#125;&#125; 123456789101112/** * @author Wangzy * @Description: 数据库记录日志 * @date 15:50 2019/12/12 */public class DatebaseLogger implements Logger &#123; @Override public void writeLogger() &#123; System.out.println(\"write datebase log!\"); &#125;&#125; 123456789101112131415161718192021222324/** * @author Wangzy * @Description: 数据方式记录日志工厂类 * @date 15:49 2019/12/12 */public class DatebaseLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; System.out.println(\"create datebase log!\"); return new DatebaseLogger(); &#125; @Override public Logger createLogger(String args) &#123; return null; &#125; @Override public Logger createLogger(Object obj) &#123; return null; &#125;&#125; 12345678910111213/** * @author Wangzy * @Description: 文件方式 * @date 15:47 2019/12/12 */public class FileLogger implements Logger &#123; @Override public void writeLogger() &#123; System.out.println(\"write file log!\"); &#125;&#125; 12345678910111213141516171819202122232425/** * @author Wangzy * @Description: 文件记录日志方式工厂 * @date 15:45 2019/12/12 */public class FileLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; System.out.println(\"create file method!\"); return new FileLogger(); &#125; @Override public Logger createLogger(String args) &#123; System.out.println(\"create file method by args!\"); return new FileLogger(); &#125; @Override public Logger createLogger(Object obj) &#123; return null; &#125;&#125; 1234567891011121314/** * @author Wangzy * @Description: 抽象产品 * @date 15:45 2019/12/12 */public interface Logger &#123; /** * @Description: 记录日志 * @author Wangzy * @date 15:48 2019/12/12 */ void writeLogger();&#125; 12345678910111213141516171819202122232425262728293031323334/** * @author Wangzy * @Description: 抽象工厂 * @date 15:42 2019/12/12 */public interface LoggerFactory &#123; /** * @Description: 创建工厂 * @author Wangzy * @date 15:43 2019/12/12 */ Logger createLogger(); /** * @Description: 抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。 * @author Wangzy * @date 16:23 2019/12/12 */ Logger createLogger(String args); Logger createLogger(Object obj); /** * @Description: 在抽象工厂类（abstract class）中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法 * @author Wangzy * @date 16:32 2019/12/12 */// public void writeLog() &#123;// Logger logger = this.createLogger();// logger.writeLogger();// &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;/** * @author Wangzy * @Description: XML工具类 * @date 16:07 2019/12/12 */public class XMLUtil &#123; /** * @Description: 该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 * @author Wangzy * @date 16:09 2019/12/12 */ public static Object getBean() &#123; try &#123; // 创建DOM文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\"src/config.xml\")); // 获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(\"className\"); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234&lt;?xml version=\"1.0\"?&gt;&lt;config&gt; &lt;className&gt;FileLoggerFactory&lt;/className&gt;&lt;/config&gt; 相关资料https://blog.csdn.net/lovelion/article/details/9306457https://blog.csdn.net/lovelion/article/details/9306745https://blog.csdn.net/lovelion/article/details/9307137https://blog.csdn.net/lovelion/article/details/9307561","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"简单工厂模式","slug":"simple-pattern","date":"2019-12-25T03:22:33.000Z","updated":"2019-12-25T07:11:53.563Z","comments":true,"path":"2019/12/25/simple-pattern/","link":"","permalink":"http://yoursite.com/2019/12/25/simple-pattern/","excerpt":"设计模式之简单工厂模式定义&emsp;&emsp;简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。 了解&emsp;&emsp;简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础。简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计。","text":"设计模式之简单工厂模式定义&emsp;&emsp;简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。 了解&emsp;&emsp;简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础。简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计。 结构图 &emsp;&emsp;Factory：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。&emsp;&emsp;Product：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。&emsp;&emsp;ConcreteProduct：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法 示例 简化&emsp;&emsp;为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在JDK等类库和框架中也广泛存在。 总结优点 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用场景 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 code123456789101112131415/** * @author Wangzy * @Description: 启动类 * @date 10:55 2019/12/12 */public class Boot &#123; public static void main(String[] args) &#123; // 配置文件读取图表类型，无需修改客户端代码，符合开闭原则 String chartType = XMLUtils.getChartType(); Chart chart = ChartFactory.getChart(chartType);// Chart chart = Chart.factoryMethod(chartType); chart.show(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * @author Wangzy * @Description: 抽象图表类 * @date 10:50 2019/12/12 */public interface Chart &#123; /** * @Description: 显示方法 * @author Wangzy * @date 10:50 2019/12/12 */ void show(); /** * @Description: 通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在JDK等类库和框架中也广泛存在 * @author Wangzy * @date 11:24 2019/12/12 */// static Chart factoryMethod(String charttype) &#123;// Chart chart = null;// // 柱状图// if (\"histogram\".equals(charttype)) &#123;// System.out.println(\"create histogram chart!\");// chart = new HistogramChart();// // 饼状图// &#125; else if (\"pie\".equals(charttype)) &#123;// System.out.println(\"create pie chart!\");// chart = new PieChart();// // 折线图// &#125; else if (\"line\".equals(charttype)) &#123;// System.out.println(\"create line chart!\");// chart = new LineChart();// &#125;// return chart;// &#125;&#125; 123456789101112131415161718192021222324252627282930/** * @author Wangzy * @Description: 简单工厂类 * @date 10:42 2019/12/12 */public class ChartFactory &#123; /** * @Description: 创建不同形式的图表 * @author Wangzy * @date 10:43 2019/12/12 */ public static Chart getChart(String charttype) &#123; Chart chart = null; // 柱状图 if (\"histogram\".equals(charttype)) &#123; System.out.println(\"create histogram chart!\"); chart = new HistogramChart(); // 饼状图 &#125; else if (\"pie\".equals(charttype)) &#123; System.out.println(\"create pie chart!\"); chart = new PieChart(); // 折线图 &#125; else if (\"line\".equals(charttype)) &#123; System.out.println(\"create line chart!\"); chart = new LineChart(); &#125; return chart; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author Wangzy * @Description: 柱状图具体类 * @date 10:51 2019/12/12 */public class HistogramChart implements Chart &#123; public HistogramChart() &#123; System.out.println(\"init histogram chart!\"); &#125; @Override public void show() &#123; System.out.println(\"show histogram chart!\"); &#125;&#125;/** * @author Wangzy * @Description: 折线图具体类 * @date 10:51 2019/12/12 */public class LineChart implements Chart &#123; public LineChart() &#123; System.out.println(\"init line chart!\"); &#125; @Override public void show() &#123; System.out.println(\"show line chart!\"); &#125;&#125;/** * @author Wangzy * @Description: 饼图具体类 * @date 10:51 2019/12/12 */public class PieChart implements Chart &#123; public PieChart() &#123; System.out.println(\"init pie chart!\"); &#125; @Override public void show() &#123; System.out.println(\"show pie chart!\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;/** * @author Wangzy * @Description: 读取配置文件工具类 * @date 11:13 2019/121/12 */public class XMLUtils &#123; /** * @Description: 该方法用于从XML配置文件中提取图表类型，并返回类型名 * @author Wangzy * @date 11:14 2019/12/12 */ public static String getChartType() &#123; try &#123; // 创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\"src/config.xml\")); // 获取包含图表类型的文本节点 NodeList nl = doc.getElementsByTagName(\"chartType\"); Node classNode = nl.item(0).getFirstChild(); String chartType = classNode.getNodeValue().trim(); return chartType; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234&lt;?xml version=\"1.0\"?&gt;&lt;config&gt; &lt;chartType&gt;histogram&lt;/chartType&gt;&lt;/config&gt; 相关资料https://blog.csdn.net/lovelion/article/details/9300337https://blog.csdn.net/lovelion/article/details/9300549https://blog.csdn.net/lovelion/article/details/9300657https://blog.csdn.net/lovelion/article/details/9300731","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之迪米特法则","slug":"lod","date":"2019-12-24T10:11:07.000Z","updated":"2019-12-25T03:17:39.990Z","comments":true,"path":"2019/12/24/lod/","link":"","permalink":"http://yoursite.com/2019/12/24/lod/","excerpt":"","text":"面向对象设计原则之迪米特法则定义迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。 了解&emsp;&emsp;如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。&emsp;&emsp;应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 注意事项&emsp;&emsp;在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 示例old new 相关资料https://blog.csdn.net/LoveLion/article/details/17517213","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之合成复用原则","slug":"crp","date":"2019-12-24T10:11:06.000Z","updated":"2019-12-25T03:17:27.083Z","comments":true,"path":"2019/12/24/crp/","link":"","permalink":"http://yoursite.com/2019/12/24/crp/","excerpt":"","text":"面向对象设计原则之合成复用原则定义合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。 了解&emsp;&emsp;合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。&emsp;&emsp;在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。&emsp;&emsp;通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。&emsp;&emsp;由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7563441","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之接口隔离原则","slug":"isp","date":"2019-12-24T10:11:05.000Z","updated":"2019-12-25T03:16:55.766Z","comments":true,"path":"2019/12/24/isp/","link":"","permalink":"http://yoursite.com/2019/12/24/isp/","excerpt":"","text":"面向对象设计原则之接口隔离原则定义接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 了解&emsp;&emsp;根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的1. interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同： 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 注意事项&emsp;&emsp;在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7562842","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之依赖倒转原则","slug":"dip","date":"2019-12-24T10:11:04.000Z","updated":"2019-12-25T03:17:13.478Z","comments":true,"path":"2019/12/24/dip/","link":"","permalink":"http://yoursite.com/2019/12/24/dip/","excerpt":"","text":"面向对象设计原则之依赖倒转原则定义&emsp;&emsp;依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 了解&emsp;&emsp;依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。&emsp;&emsp;在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。&emsp;&emsp;在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7562783","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之里氏代换原则","slug":"lsp","date":"2019-12-24T10:11:03.000Z","updated":"2019-12-25T03:16:26.702Z","comments":true,"path":"2019/12/24/lsp/","link":"","permalink":"http://yoursite.com/2019/12/24/lsp/","excerpt":"","text":"面向对象设计原则之里氏代换原则定义&emsp;&emsp;里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。&emsp;&emsp;严格表述：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。 了解&emsp;&emsp;里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。&emsp;&emsp;例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。&emsp;&emsp;里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 注意事项 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7540445","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之开闭原则","slug":"ocp","date":"2019-12-24T10:11:02.000Z","updated":"2019-12-25T03:16:40.462Z","comments":true,"path":"2019/12/24/ocp/","link":"","permalink":"http://yoursite.com/2019/12/24/ocp/","excerpt":"","text":"面向对象设计原则之开闭原则定义&emsp;&emsp;开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 ###了解&emsp;&emsp;任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。&emsp;&emsp;为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。如在java中可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7537584","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之单一职责原则","slug":"srp","date":"2019-12-24T10:11:01.000Z","updated":"2019-12-25T03:09:29.805Z","comments":true,"path":"2019/12/24/srp/","link":"","permalink":"http://yoursite.com/2019/12/24/srp/","excerpt":"","text":"面向对象设计原则之单一职责原则定义&emsp;&emsp;单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 了解&emsp;&emsp;在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7536542","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Spring Boot","slug":"springboot01","date":"2019-12-19T02:55:01.000Z","updated":"2019-12-19T02:55:50.115Z","comments":true,"path":"2019/12/19/springboot01/","link":"","permalink":"http://yoursite.com/2019/12/19/springboot01/","excerpt":"初识Spring Boot一. Spring的java配置方式Spring4.x推荐的配置方式，可以完全替代xml配置, 常用注解: @Configuration（作用于类上，相当于一个xml配置文件）； @Bean（作用于方法上，相当于xml配置中的bean标签） @ComponentScan（basePackages = &quot;配置类所在包&quot;） @PropertySource（value=&quot;指定配置文件&quot;，ignoreResourceNotFound = true） @Value（&quot;${key}&quot;）获取配置文件中的值 二. Spring Boot &emsp;&emsp;“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，无需手动），项目独立运行（运行jar，内嵌Servlet容器），使用它可以不用或只需要很少的Spring配置。","text":"初识Spring Boot一. Spring的java配置方式Spring4.x推荐的配置方式，可以完全替代xml配置, 常用注解: @Configuration（作用于类上，相当于一个xml配置文件）； @Bean（作用于方法上，相当于xml配置中的bean标签） @ComponentScan（basePackages = &quot;配置类所在包&quot;） @PropertySource（value=&quot;指定配置文件&quot;，ignoreResourceNotFound = true） @Value（&quot;${key}&quot;）获取配置文件中的值 二. Spring Boot &emsp;&emsp;“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，无需手动），项目独立运行（运行jar，内嵌Servlet容器），使用它可以不用或只需要很少的Spring配置。 常用注解 @SpringBootApplication（核心注解，用于开启自动配置） 注：自动配置的东西会很多，若想关闭某一项配置 @SpringBootApplication(exclude = {RedisAutoConfiguration.class}) 手动关闭Redis配置 @Configuration @ConditionalOnMissingBean（当容器里没有指定的Bean的情况下创建该对象） @AutoConfigureAfter（*.class）保证在括号内的类实例化完成之后在实例化该类，注解加在类上 注： @ResponseBody：两个作用，首先，将响应结果直接写入HTTP response body中，不会被解析为跳转路径；直接将响应结果以json形式返回； 启动应用通过main方法启动，启动类应在被扫描包的同级或上级包里 全局配置文件 &emsp;&emsp;application.properties 或 application.yml,可以放在resources目录下或者类路径下的/config下，一般是放到resources目录下的 比如：修改tomcat的端口为8088server.port=8088,更多的配置在文件里有参考 Starter pom &emsp;&emsp;个人理解为SpringBoot为我们提供了绝大多数的配置，放置在parent里面，应用的时候，根据具体的业务场景导入相应的依赖也就是Starter pom，就可以实现零配置使用默认配置好的bean，也可以在全局配置里修改默认的配置。 xml配置文件 &emsp;&emsp;可能有一些特殊要求必须使用xml配置，应用注解@ImportResource来加载xml配置 注: &emsp;&emsp;在进行SpringApplication对象实例化的时候会加载META-INF/spring.factories文件，并将该配置文件载入到Spring容器 自定义配置 &emsp;&emsp;如：SpringMVC配置，比如增加一个拦截器，这个时候可以通过继承WebMvcConfigurerAdapter然后重写父类中的方法进行扩展。 事务的配置 &emsp;&emsp;在引入jdbc依赖之后，直接使用@Transactional注解即可，可加在类上，也可以加在方法上 注：内嵌的tomcat是不支持jsp页面的，因此应导入额外的包才能解决 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"Linux命令","slug":"linux02","date":"2019-12-19T02:54:01.000Z","updated":"2019-12-19T02:54:37.427Z","comments":true,"path":"2019/12/19/linux02/","link":"","permalink":"http://yoursite.com/2019/12/19/linux02/","excerpt":"一. Linux命令格式command 【-options】 【parameter1】… 注: &emsp;&emsp;command：命令名，相应功能的英文单词或单词的缩写 &emsp;&emsp;【-options】：选项，可用来对命令进行控制，也可以省略 &emsp;&emsp;【parameter】：传给命令的参数，可以是0个1个或多个 &emsp;&emsp;[]里的内容是代表可选","text":"一. Linux命令格式command 【-options】 【parameter1】… 注: &emsp;&emsp;command：命令名，相应功能的英文单词或单词的缩写 &emsp;&emsp;【-options】：选项，可用来对命令进行控制，也可以省略 &emsp;&emsp;【parameter】：传给命令的参数，可以是0个1个或多个 &emsp;&emsp;[]里的内容是代表可选 二. 查看帮助文档1. command –help2. man(manual)注: &emsp;&emsp;man是linux提供的一个手册，包含了绝大部分的命令以及函数使用说明涉及到功能键及功能： 空格： 显示手册页的下一屏 Enter：一次滚动手册页的一行 b： 回滚一屏 f： 前滚一屏 q： 退出 h： 列出所有功能键 /word：搜索word字符串 三. 历史命令上下键或用history将执行过的命令列举出来 四. Linux命令–文件, 磁盘管理1. ll&amp;ls1.1 文件管理 ls 查看文件信息 注: 以.(点)开头的文件为隐藏文件， 需要用-a参数才能显示-a 显示制定目录下所有子目录与文件，包括隐藏文件-l 以列表方式显示文件的详细信息-h 配合-l以人性化的方式显示文件大小其实一个ll解决一切 1.2 通配符 &emsp;&emsp;*（星号）代表文件名中所有字符,?（问号）代表文件名中任意一个字符,[] (方括号) 将字符组括起来，表示可以匹配字符组中的任意一个。其中‘-（中杠）’表示字符范围. &emsp;&emsp;如： ls [a-f]* 查找并显示a到f范围内的任意一个字符开头的文件\\ (反斜杠) 如果想使通配符作为普通字符用，可以在其前面加上转义字符。另外‘?’和‘*’处于方括号内时不需要使用转义字符就失去了通配符的作用如： ls *a 查找文件名为*a的文件 2. 输出重定向命令：&gt;&emsp;&emsp;将命令执行结果重定向到一个文件， 本应该显示在终端上的内容保存到制定文件中 &emsp;&emsp;如： ls &gt; test.txt(文件若不存在，则创建，若存在则覆盖其中的内容) &emsp;&emsp;注： 可以用cat查看文件的内容，&gt; 输出重定向会覆盖原来的内容， &gt;&gt; 输出重定向则会追加到文件的尾部 3. 分屏显示: more&emsp;&emsp;查看内容时， 在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按空格键可以显示下一页，按q键退出显示，按h键获取帮助。 4. 管道: |&emsp;&emsp;什么是管道，就是一个命令的输出可以通过管道作为另一个命令的输入，通俗一点来讲就是将查寻到或者其他方式得到的数据放到所谓的管道里面，然后对数据继续进行操作 5. 清屏：clear或Ctrl + l6. 切换工作目录： cd&emsp;&emsp;其后可以跟绝对路径，也可以跟相对路径，如果省略目录的话，就默认切换到当前用户的主目录（此时相当于cd~） cd . 切换到当前目录 cd .. 切换到上级目录 cd - 切换到上次所在的目录 注: &emsp;&emsp;Linux所有的目录和文件名大小写敏感，如果路径是从根据径开始的，其前面需要加上‘/’， 而通常进入某个目录里的文件夹，前面不需要加 7. 显示当前路径： pwd8. 创建目录：mkdir参数-p可递归创建目录 &emsp;&emsp;注意新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写的权限 tree： 以目录树的方式显示，显示文件夹层级关系是极好的 9. 删除目录：rmdir10. 删除文件： rmrm可以删除文件和目录。 注意： 文件删除后是不能恢复的，为了防止文件误删，可以在rm后使用-i参数来逐个确认要删除的文件 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归删除目录下的内容，删除文件夹时必须加这个参数 11. 建立链接文件: ln(了解一下)类似与Windows下的快捷方式，分为软连接和硬链接 11.1 软连接：不占用磁盘空间，源文件删除软链接就失效 格式: ln -s 源文件 链接文件 11.2 硬链接: 只能链接普通文件，不能链接目录 格式: ln 源文件 链接文件 注: &emsp;&emsp;建立起的硬链接文件，两个文件占用相同大小的磁盘空间，即使删除了源文件，链接文件还是存在的，因此类似于Windows的快捷方式，软连接是更常见的一种形式； 另外，如果软连接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径 12. 查看或者合并文件内容：cat例如: cat test.txt test2.txt &gt; helloworld.txt 注: &emsp;&emsp;linux的文件不是通过后缀区分的，不一定非是*.txt才是文本文件，通常通过文件的颜色就能区分出是文件或者文件夹 13. 文本搜索: grep是一个强大的文本搜索工具，允许对文本文件进行模式查找。如果找到匹配模式，grep打印包含模式的所有行 13.1 一般格式 grep [-选项] &apos;搜索内容串&apos;文件名 注: &emsp;&emsp;在grep命令中输入字符串参数时，最好用引号括起来，如：grep ‘a’ text.txt,另，linux里是不区分单引号还是双引号的 13.2 常规选项说明 -v: 显示不包含匹配文本的所有行（相当于求反） -n: 显示匹配行及行号 -i: 忽略大小写 注: grep搜索的内容串也可以是正则表达式 14. 查找文件：find&emsp;&emsp;通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件常用语法： 15. 拷贝文件 cp其主要功能是将给出的文件或目录复制到另一个文件或目录中 常用选项: -a：该选项通常在复制目录时使用，它会保留链接，文件属性，并递归地复制目录，简而言之，保持文件的原有属性 -f：已经存在的目标文件而不提示，直接覆盖 -i：交互式复制，在覆盖目标文件之前给出提示要求用户确认 -r：若给出的源文件时目录文件，则cp将递归复制该目录下所有的子目录和文件，目标文件必须为一个目录名 -v：显示拷贝进度 16. 移动文件 mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名 常用选项: -f：禁止交互式操作，即使有覆盖也不给出提示 -i：交互式操作 -v: 显示移动进度 17. 归档管理 tar&emsp;&emsp;tar是Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，亦可以将档案文件解开以恢复数据 17.1 使用格式 tar [参数] 打包文件名 文件 注: tar命令的参数前面既可以使用‘-’，也可以不使用 17.2 常用参数: -z：制定压缩包的格式为：file.tar.gz -c：生成档案文件，创建打包文件 -v：列出归档解档的详细过程，显示进度 -t：列出档案中包含的文件 -x：解开档案文件 -f：指定档案文件名称，f后面一定是.tar文件，因此务必要放选项最后，但其他参数随意 18. 文件压缩与解压缩 gzip&emsp;&emsp;tar与gzip命令结合使用方可实现文件打包，压缩。tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxx.tar.gz 18.1 使用格式: gzip [选项] 被压缩文件 18.2 常用选项: -d：解压 -r：压缩所有子目录（默认不加选项也是压缩） 注：上面的其实没多大卵用，并且麻烦的雅痞，因此在tar命令中增加了一个选项（-z），此时就可以调用gzip从而实现一个压缩的功能，完成先打包后压缩的过程 18.3 压缩用法 tar -zcvf 压缩包包名 文件1 文件2... 注：不同的压缩方式算法不同，因此压缩的速度以及大小均不同，综合起来而言，推荐使用的是tar -zcvf 18.4 解压缩用法 tar -zxvf 压缩包包名 注：默认是解压到当前路径下，要解压到指定目录下可以用选项‘-C’ 19. 文件压缩与解压缩 bzip2&emsp;&emsp;其用法和gzip一样，压缩文件的扩展名一般用：xxx.tar.gz2, 具体实现方式在tar命令中增加一个（-j）选项即可 压缩及解压缩用法： 如： tar -jcvf demo.tar.bz2 *.test tar -jxvf demo.tar.bz2 20. 文件压缩与解压缩：zip 、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 压缩及解压缩用法： zip [-r] 目标文件（无需扩展名） 源文件 unzip -d 解压后目录文件 压缩文件 21. 查看命令位置 which&emsp;&emsp;如果找到就显示这个命令的路径，找不到就不显示呗，了解一下，没什么卵用 五. Linux命令-系统管理1. 查看当前日历 cal（-y显示整年）2. 显示或设置时间： date2.1 设置时间格式(需要管理员权限) date [MMDDhhmm[[CC]YY][.ss]] +format 注：CC为年前两位yy为年的后两位，前两位的mm为⽉，后两位的mm为分钟，dd为天，hh为 ⼩时，ss为秒。如： date 010203042016.55。 2.2 显示时间格式 date &apos;+%y,%m,%d,%H,%M,%S&apos; 如：date &apos;+%Y/%m/%d&apos; ==&gt;xxxx/xx/xx 注：y/Y效果一样 3. 查看进程信息 ps此命令可以查看进程的详细状况 常用选项（‘-可以省略’）: -a：显示终端上的所有进程，包括其他用户的进程 -u：显示进程的详细状态 -x：显示没有控制终端的进程 -w：显示加宽，以便显示更多的信息 -r：只显示正在运行的进程 4. 动态显示进程 top&emsp;&emsp;用来动态显示运行中的进程，能够再运行之后，在指定的时间间隔更新显示信息，可以通过加选项[-d]来指定显示信息更新的时间间隔 常用按键： M：根据内存使用量排序 P：根据CPU占有率排序 T：根据进程运行时间长短排序 U：根据后面输入的用户名来筛选进程 K：根据后面输入的PID杀死进程 q：退出 h：帮助 5. 终止进程：kill 杀死指定进程号的进程，需要配合ps使用 格式: kill [-signal] pid 注: 其中信号值选项从0到15，9为绝对终止，可以处理一般信号无法终止的进程 6. 关机重启：reboot、shutdown、init如: reboot 重新启动操作系统 shutdown -h now 立刻关机 shutdown -h 20:25 定时关机 shutdown -h +10 系统过十分钟自动关机 init 0 关机 init 6 重启 7. 检测磁盘空间: df&emsp;&emsp;用于检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况 常用选项： -a：显示所有文件系统的磁盘使用情况 -m：以1024字节为单位显示 -t：显示各指定文件系统的磁盘空间使用情况 -T：显示文件系统 8. 检测目录所占磁盘空间：du&emsp;&emsp;用于统计目录或文件所占磁盘空间的大小，该命令的执行结果与df类似，du更测重于磁盘的使用情况 格式: du [选项] 目录或文件名 -a：递归显示指定目录中各文件和子目录中文件占用的数据块 -s：显示指定文件或目录占用的数据块 -b：以字节为单位显示磁盘占用情况 -l：计算所有文件大小，对硬链接文件计算多次 注：在后面加-h可以转换单位，如：du -s build/ -h 显示指定文件占用的数据块，并转换单位 9. 查看或配置网卡信息：ifconfig默认显示所有的网卡信息 &emsp;&emsp;另外，修改网卡的ip地址信息：ifconfig + 网卡名 + 新ip地址，如果权限不足，加sudo，或者通过sudo su切换到root用户操作 10. 测试远程主机联通性：pingping www.baidu.com ping 192.168.1.1 六. Linux命令-用户、权限管理&emsp;&emsp;用户管理包括用户与组账号的管理，无论是由本机或是远程登陆系统，每个系统必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限，root是用于系统的维护和管理的，拥有不受限制的访问权限；再Linux的安装过程中系统会自动创建许多用户账号，这些默认被创建的用户称为‘标准用户’，通常不推荐直接使用root账号登陆系统 1. 查看当前用户：whoami&emsp;&emsp;用户可以使用该命令查看当前系统当前账号的用户名，还可以通过cat /etc/passwd查看系统用户信息 2. 查看登陆用户：who用于查看当前所有登录系统的用户信息，通俗点就是谁登陆了此系统都会显示出来 常用选项: -m或am I ：只显示运行who命令的用户名、登陆终端和登陆时间 -q或--count：只显示用户的登陆账号和登陆用户的数量 -u或--heading：显示列标题 3. 退出登陆用户：exit如果是图形界面，退出当前终端； 如果是使用ssh远程登陆，退出登陆用户； 如果是切换后的登陆用户，退出并返回上一个登陆账号 4. 添加用户账号 useradd使用格式： useradd [选项] 新建用户账号 常用选项: -d：指定用户登陆系统时的主目录，如果不使用该参数，系统就自动再/home目录下面建立与用户名同名目录作为主目录 -m：自动建立目录 -g：指定组名称 注：adduser的命令是指向useradd的一个链接，两个命令的格式完全一样，作用也是一样的； Linux每个用户都有一个主目录，主目录即第一次登陆系统，用户的默认当前目录 （/home/user）； 创建用户的时候，一定要给用户指定一个主目录，因为每一个用户必须要有一个主目录； 用户的主目录一般要放在根目录的home目录下，用户的主目录和用户名是相同的，走默认的即可，前面的约等于扯犊子； 如果创建用户的时候没有指定组名，那么系统也会自动创建一个和用户名一样的组名 一句话，走默认，就够了 如：useradd -d /home/a a -g test 创建一个用户名字叫a，主目录在/home/a, 如果主目录不存在，就自动创建主目录，同时用户属于test组 5. 设置用户密码 passwd&emsp;&emsp;超级用户可以使用passwd命令为普通用户设置或修改用户口令；用户也可以直接使用该命令来修改自己的口令，并且不需要在命令后面使用用户名 6. 删除用户 userdel常用格式： userdel abc : 删除abc用户，但并不会自动删除用户的主目录 userdel -r abc : 删除用户同时删除用户的主目录 7. 切换用户 su&emsp;&emsp;通过此命令切换用户，后面也可以加‘-’中杠，其作用是在切换到对应的用户时会将当前的工作目录自动转换到切换后的用户主目录 注: &emsp;&emsp;在命令前加‘sudo’ 允许系统管理员让普通用户执行全部root权限命令，减少了root用户的登陆和管理时间；（sudo）su 默认切换到root用户；$表示普通用户， #表示root用户 8. 查看有哪些用户组method1: cat /etc/group method2: groupmod + 三次tab键 9. 添加、删除组账号 groupadd groupdel格式: groupadd / groupdel + 组账号 注：一般会报权限不足，应在命令前加sudo 10. 修改用户所在的组 usermod格式: usermod -g 用户组 用户名 注: 查询是否修改成功 cat /etc/group | grep XXX 11. 查看用户在哪些组 groups 12. 为创建的普通用户添加sudo权限sudo usermod -a -G adm 用户名 sudo usermod -a -G sudo 用户名 注：usermod -g 与 -G的区别 -g：用来指定这个用户默认的用户组 -G：一般配合-a来完成向其它组添加 13. 修改文件权限 chmod13.1 字母法： 注： u（user）表示该文件的所有者 g（group）表示与该文件的所有者属于同一组者，也即用户组 o（other） 表示其他以外的用户 a（all） 表示所有，包括以上三者 + 增加权限 - 撤销权限 = 设定权限 13.2 数字法: rwx这些权限是可以用数字来代替的 r：读取权限，数字代号为4 w：写入权限，数字代号为2 x：执行权限，数字代号为1 -：不具备任何权限，数字代号为0 如：执行chmod u=rwx，g=rx, o=r filename等同于：chmod u=7,g=5,o=4 filename也等同于 chmod 751 filename； 另，若想递归所有目录加上相同权限，需加上参数‘-R’ 如：chmod 777 test/ -R 可递归test目录下所有文件并加777权限 14. 修改文件所有者 chown格式： chown + 文件所有者 + 文件名 15. 修改文件所属组 chgrp格式：chgrp + 文件所属组 + 文件名 七. Vim编辑器及相关命令&emsp;&emsp;vi（Visual interface）,即可视化界面，分为三种基本工作模式：命令模式、文本输入模式、末行模式vim是从vi发展出来的一个文本编辑器，下面为它的基础操作 1. 进入插入模式:i：插入光标前一个字符 I：插入行首 a：插入光标后一个字符 A：插入行末 o：向下新开一行，插入行首 O：向上新开一行，插入行首 2. 进入命令模式：ESC：会从插入模式或末行模式进入命令模式 3. 移动光标：h: 左移 j: 下移 k: 上移 l: 右移 M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行,行号 -G w: 向后一次移动一个字 b: 向前一次移动一个字 {: 按段移动,上移 }: 按段移动,下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏 gg: 光标移动文件开头 G: 光标移动到文件末尾 4. 删除命令x: 删除光标后一个字符,相当于 Del X: 删除光标前一个字符,相当于 Backspace dd: 删除光标所在行,n dd 删除指定的行数 D: 删除光标后本行所有内容,包含光标所在字符 d0: 删除光标前本行所有内容,不包含光标所在字符 dw: 删除光标开始位置的字,包含光标所在字符 5. 撤销命令u：一步步撤销 Ctrl - r：反撤销 6. 重复命令.(点): 重复上一次操作的命令 7. 文本行移动&gt;&gt;: 文本行右移 &lt;&lt;: 文本行左移 8. 复制粘贴yy：复制当前行，n yy 复制n行 p：在光标所在位置向下开辟一行并粘贴 9. 可视模式v：按字符移动，选中文本 V：按行移动，选中文本可视模式可以配合d，y，&gt;&gt;, &lt;&lt;实现对文本块的删除，复制以及左右移动 10. 替换操作r：替换当前字符 R：替换当前行光标后的字符 11. 查找命令/：str查找 n：下一个 N：上一个 12. 替换命令如：把abc全部替换成123 末行模式下，将当前文件中的所有abc替换成123 ：%s/abc/123/g 末行模式下，将第一行至第10行之间的abc替换成123 ：1，10s/abc/123/g 注: 若在vim里执行shell下命令，可以通过在末行模式里输入！，后面跟命令即可 八. 分屏操作(进阶)1. 常用分屏操作:sp：上下分屏，后可跟文件名 vsp：左右分屏，后可跟文件名 Ctrl+w+w：在多个窗口切换 2. 启动分屏:2.1 使用大写O选项进行垂直分屏 格式：vim -On file1 file2 ... 2.2 使用小写o参数进行水平分屏 格式：vim -on file1 file2 ... 注：n是数字，表示分屏的数量，要保证n大于等于文件的个数 3. 关闭分屏:3.1 关闭当前窗口 Ctrl + w c 3.2 关闭当前窗口，如果只剩最后一个，则退出vim Ctrl + w a 4. 编辑中分屏4.1 上下分割当前打开的文件 Ctrl+w s 4.2 上下分割，并打开一个新的文件 ：sp filename 4.3 左右分割当前打开的文件 ctrl+w v 4.4 左右分割，并打开一个新的文件 ：vsp filename 5. 分屏编辑中光标的移动&emsp;&emsp;vi中的光标键是h，j，k，l，要想在各个屏之间切换，只需要先按一下Ctrl+w 把光标移动到上边的屏 ctrl + w k 把光标移动到下一个屏 ctrl + w w 6. 移动分屏如: 向上移动：ctrl+w K(大写，其他参考光标键) 7. 屏幕尺寸7.1 增加高度 ctrl+w + 7.2 减少高度 ctrl+w - 7.3 让所有的屏高度一致 ctrl+w = 7.4 左加宽度 ctrl+w &gt; 7.5 右加宽度 ctrl+w &lt; 7.6 右增加n宽(如: n = 30) ctrl + w n &lt;","categories":[{"name":"linux学习","slug":"linux学习","permalink":"http://yoursite.com/categories/linux学习/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"初识Linux","slug":"linux01","date":"2019-12-19T02:53:01.000Z","updated":"2019-12-19T02:53:59.200Z","comments":true,"path":"2019/12/19/linux01/","link":"","permalink":"http://yoursite.com/2019/12/19/linux01/","excerpt":"Linux系统没有盘符的概念, 只有一个根目录”/“, 所有的文件都在这个根目录下面 一. 目录1. “/“&emsp;&emsp;根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西 都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目 录）开始，再进入到home目录。","text":"Linux系统没有盘符的概念, 只有一个根目录”/“, 所有的文件都在这个根目录下面 一. 目录1. “/“&emsp;&emsp;根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西 都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目 录）开始，再进入到home目录。 2. /bin、/usr/bin&emsp;&emsp;可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 3. /dev&emsp;&emsp;存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备， 常用的是挂载光驱 mount /dev/cdrom /mnt。 4. /etc&emsp;&emsp;系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文 件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d等。 5. /home&emsp;&emsp;系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录 下，~表示当前用户的家目录，如: ~edu 表示用户 edu 的家目录。 6. /lib、/usr/lib、/usr/local/lib&emsp;&emsp;系统使用的函数库的目录，程序在执行过程中，需要调 用一些额外的参数时需要函数库的协助。 7. /lost+fount&emsp;&emsp;系统异常产生错误时，会将一些遗失的片段放置于此目录下。 8. /opt&emsp;&emsp;给主机额外安装软件所摆放的目录。 9. /proc&emsp;&emsp;此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。 10. /root&emsp;&emsp;系统管理员root的家目录。 11. /sbin、/usr/sbin、/usr/local/sbin&emsp;&emsp;放置系统管理员使用的可执行命令，如fdisk、 shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命 令，一般用户只能”查看”而不能设置和使用。 12. /boot&emsp;&emsp;放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz 13. /tmp&emsp;&emsp;一般用户或正在执行的程序临时存放文件的目录，任何⼈都可以访问，重要数据不可放置在此目录下。 14. /srv&emsp;&emsp;服务启动之后需要访问的数据目录，如 www 服务需要访问的⽹⻚数据存放在 /srv/www 内。 15. /usr&emsp;&emsp;应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放 软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。 16. /var&emsp;&emsp;放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放 的目录，/var/run:程序或服务启动后，其PID存放在该目录下。 二. 路径 相对路径: 从当前位置开始描述的路径为相对路径 绝对路径: 从”/“目录开始描述的路径为绝对路径 三. 点(.)和点点(..) 每个目录下都有点和点点 点表示当前目录 点点表示上一级目录也就是父目录 “/“路径下的点和点点都表示当前目录 四. 访问权限用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读，写，及执行的权限 读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的 权限。 写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删 除、移动目录内文件的权限。 可执行权限（x） 对文件而言，具有执行文件的权限；对目录了来说该用户具有进入 目录的权限。 注: &emsp;&emsp;第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设 备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后 9 个字母分别代表三 组权限：文件所有者、用户组、其他用户拥有的权限。 每一个用户都有它自身的读、写和执行权限。&emsp;&emsp;这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构 成了一个有9种类型的权限组。","categories":[{"name":"linux学习","slug":"linux学习","permalink":"http://yoursite.com/categories/linux学习/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"异常","slug":"exception","date":"2019-12-19T02:50:01.000Z","updated":"2019-12-19T02:51:51.469Z","comments":true,"path":"2019/12/19/exception/","link":"","permalink":"http://yoursite.com/2019/12/19/exception/","excerpt":"初识异常&emsp;&emsp;异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。&emsp;&emsp;Throwable类是Java异常类型的顶级父类, 其又派生出Error类和Exception类; JDK中创建了一些常用的异常类, 当然也可以通过自定义的方式创建异常.Error类以及他的子类的实例，代表了JVM本身的错误。错误不能通过代码处理. Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件,可以被Java异常处理机制使用，是异常处理的核心。","text":"初识异常&emsp;&emsp;异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。&emsp;&emsp;Throwable类是Java异常类型的顶级父类, 其又派生出Error类和Exception类; JDK中创建了一些常用的异常类, 当然也可以通过自定义的方式创建异常.Error类以及他的子类的实例，代表了JVM本身的错误。错误不能通过代码处理. Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件,可以被Java异常处理机制使用，是异常处理的核心。 一. java异常的分类 非检查异常/运行时异常: 编译阶段不会报错, 运行时才出现问题, 如Error, NullPointerException, ArrayIndexOutOfBoundsException等 检查异常/编译时异常: 编译阶段就要求处理, 要么抛出, 要么捕获, 如SQLException, IOException, ClassNotFoundException等 二. 初识异常&emsp;&emsp;异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。 如果没有使用任何异常处理机制, 异常最终会抛给JRE, 导致程序终止 三. 异常处理的基本语法&emsp;&emsp;在编写代码时, 针对编译时异常有两种处理方式(机制), 使用try…catch…finally语句块处理它。或者，在函数签名中使用throws 声明交给函数调用者caller去解决。 try起来: try: 1. try块中放可能发生异常的代码。 2. 如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。 3. 如果发生异常，则尝试去匹配catch块。 catch: 1. 每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7以后可以将多个异常声明在一个catch中。 2. catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 3. 在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 4. 如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，(注)然后到这个函数的外部caller中去匹配异常处理器。 5. 如果try中没有发生异常，则所有的catch块将被忽略。 finally: 1. 无论异常是否发生，异常是否匹配被处理，finally都会执行。 2. finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 注意: 异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。 当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。 良好的习惯: 再try里打开资源, 连接, 再finally里关闭 抛出去: 通过throws关键字实现, 它仅仅是将函数中可能出现的异常向调用者声明, 而自己不具体进行处理, 一方面是方法本身不知道如何处理这种异常, 另一方面是可能让调用者处理更好, 或者说调用者需要为可能发生的异常负责. 四. throw关键字&emsp;&amp;emsp可以通过这个关键字手动显示的抛出一个异常, 其后面必须跟一个异常对象, throw语句必须写在函数中, 执行这个语句的地方就是异常抛出点, 这和JRE自动形成的异常抛出点没有任何差别 五. 自定义异常 实现方式:继承Exception或RuntimeException类 实现规则: 必须包含如下构造函数 一个无参构造 一个带有String参数的构造, 并传递给父类构造 一个带有Throwable参数的构造, 并传递给父类构造 一个带有String参数Throwable参数的构造, 并都传递给父类构造 具体可参考源码的异常定义规则, 如IOException 六. 异常的注意事项 当子类重写父类的带有throws声明的函数时, 其throws声明的异常必须在父类异常的可控范围内, 目的是为了实现多态;比如父类throws了IOException, 子类就必须throws这个异常或这个异常的子类 java中的异常是线程独立的, 这样不会影响到其他线程的执行, 也不至于出了异常一旦没有任何代码处理就导致程序终止 七. 不得其解finally在try语句块中即便有return, break, continue等改变执行流的语句, finally也是会执行的 finally中的return会覆盖try或者catch中的返回值 finally中的return会抑制try或者catch中的异常 finally中的异常会覆盖try或者catch中的异常","categories":[{"name":"exception","slug":"exception","permalink":"http://yoursite.com/categories/exception/"}],"tags":[{"name":"exception","slug":"exception","permalink":"http://yoursite.com/tags/exception/"}]},{"title":"git从github下载内容","slug":"git01","date":"2019-12-19T02:49:01.000Z","updated":"2019-12-19T02:52:32.571Z","comments":true,"path":"2019/12/19/git01/","link":"","permalink":"http://yoursite.com/2019/12/19/git01/","excerpt":"git和github相关操作 右键选择”Git Bash Here”，在弹出的命令框中，输入：","text":"git和github相关操作 右键选择”Git Bash Here”，在弹出的命令框中，输入： ssh-keygen -t rsa -C “your_email@youremail.com“然后会要求确认路径和输入密码，全部直接按回车默认即可。 如果上一步操作成功，则会在c:\\users(你的电脑名).ssh\\下面生成3个文件。用记事本打开id_rsa.pub，然后全选里边的内容。 在网页中登陆你的Git账号，然后打开ssh keys设置网页。可以在设置(setting)中找到SSH keys选项，也可以在登陆成功的前提下直接点击我给出的链接。 点击”Add SSH key”，Title随便填，Key里边粘贴进去在(2)中复制的全部数据。然后点击”Add key”。网页会提示添加成功。 验证是否成功。回到命令框下，输入 ssh -T git@github.com ，如果询问是否继续，输入yes后回车。如果成功，会看到You’ve successfully authenticated, but GitHub does not provide shell access。则表示连接成功。 设置变量。继续在命令框中输入 git config --global user.name &apos;wangzy&apos; git config --global user.email &apos;wangzhiyang199602@163.com&apos; 在网页中手动创建一个repository。比如名称为test，并且选中创建README.md 连接好之后开始下载 8.1 在创建完成后的网页右侧找到 HTTPS clone URL，然后复制。 8.2 打开想要将该仓库下载的目录位置，然后右键选择”Git Bash Here”。输入 git clone http://10.214.168.204:8081/liunan1944/test01.git网址换成你自己的。如果成功，会显示下载了几个文件等信息。 8.3 初始化readme文件，如果已经初始化好了，进行(4)。如果有提示输入username的，建议输入邮箱地址。 8.3.1. git init 8.3.2. touch README.md 8.3.3. git add README.md 8.3.4. git commit -m ‘your infomation’ 8.3.5. git remote add origin https://github.com/…. 8.3.6. git push origin master 问题及解决方法 9.1 github提示Permission denied(public-key) 首先, 清除所有的key-pair ssh-add -D rm -r ~/.ssh 9.2 重新生成ssh密钥对 ssh-keygen -t rsa -C “xxx@xxx.com“","categories":[{"name":"git&github","slug":"git-github","permalink":"http://yoursite.com/categories/git-github/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"Java学习路线","slug":"helloskills","date":"2019-12-19T02:45:01.000Z","updated":"2019-12-19T02:52:12.039Z","comments":true,"path":"2019/12/19/helloskills/","link":"","permalink":"http://yoursite.com/2019/12/19/helloskills/","excerpt":"java技术栈java基础 异常 反射 枚举 注解 继承和多态 泛型 数据结构 内存与JVM 集合 内部类 JDK新特性 设计模式 线程 I/O","text":"java技术栈java基础 异常 反射 枚举 注解 继承和多态 泛型 数据结构 内存与JVM 集合 内部类 JDK新特性 设计模式 线程 I/O J2EE web 主流开发框架 Spring及源码 SpringMVC及源码 Mybatis和JPA Struts和Hibernate(了解) Spring Boot Spring Cloud 前端框架及技术 jQuery JavaScript HTML, CSS(了解) Vue React Ajax EasyUI BootStrap 主流开发技术 JDBC Mysql 分库分表 读写分离 (分布式)事务 Oracle MQ消息队列 Redis POI httpClient Servlet WebService Socket Netty Maven 容器及服务器 tomcat Jetty Nginx Docker Weblogic FastFDS 高并发及处理 定时任务调度 权限校验 原生控制表数据 Shiro Spring Security Canal 同步与异步 测试与日志打印 Junit log4j 编码与加解密 AES MD5 XML DOM Json Restful 项目管理 git github Subversion Linux aop ELK Elasticsearch Lucene Solr LogStash Kibana JSP Zookeeper Dubbo 单点登录 Mycat 监听器 过滤器 拦截器 进阶 区块链 大数据 Python learn a little per day, you will be the winner!","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"http://yoursite.com/categories/Java技术栈/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/技术栈/"}]},{"title":"Linux命令安装Elastic Search","slug":"Linux安装elasticsearc7.1.1","date":"2019-12-19T02:05:06.000Z","updated":"2019-12-19T02:30:53.381Z","comments":true,"path":"2019/12/19/Linux安装elasticsearc7.1.1/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装elasticsearc7.1.1/","excerpt":"Linux(Centos7.6)安装elasticsearch-7.1.1 下载：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.1.1-linux-x86_64.tar.gz","text":"Linux(Centos7.6)安装elasticsearch-7.1.1 下载：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.1.1-linux-x86_64.tar.gz 上传到/opt文件夹并解压 1tar zxvf elasticsearch-7.1.1-linux-x86_64.tar.gz 在解压后的elasticsearch目录里新建data目录 1mkdir data 修改config/elasticsearch.yml 12345678vim /opt/elasticsearch-7.1.1/config/elasticsearch.ymlcluster.name: my-application #集群名称node.name: node-1 #节点名称path.data: /opt/elasticsearch-7.1.1/data #数据和日志的存储目录path.logs: /opt/elasticsearch-7.1.1/logsnetwork.host: 0.0.0.0 #设置绑定的ip，设置为0.0.0.0以后就可以让任何计算机节点访问到了http.port: 9200 #端口cluster.initial_master_nodes: [\"node-1\"] #设置在集群中的所有节点名称，这个节点名称就是之前所修改的，当然你也可以采用默认的也行，目前是单机，放入一个节点即可 修改内存 12345vim /opt/elasticsearch-7.1.1/config/jvm.options -Xms200m-Xmx200m解决报错：Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c5330000, 986513408, 0) failed; error='Cannot allocate memory' (errno=12) es6.0版本往后的版本不支持root用户启动，需创建用户（es） 123groupadd es #创建用户组useradd es -g es #创建用户chown -R es:es /opt/elasticsearch-7.1.1 #给用户增加权限 解决报各种大小限制问题 1234567891011vim /etc/security/limits.confes soft nofile 65536es hard nofile 65536es soft nproc 4096es hard nproc 4096vim /etc/security/limits.d/20-nproc.confes soft nproc 4096root soft nproc unlimitedvim /etc/sysctl.confvm.max_map_count = 655360sysctl -p #执行查看是否生效 切换到es用户启动es 1./bin/elasticsearch -d(后台启动) 查看进程 1ps -ef | grep elasticsearch","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"elasticsearch7","slug":"elasticsearch7","permalink":"http://yoursite.com/tags/elasticsearch7/"}]},{"title":"Linux命令安装Redis","slug":"Linux安装redis3.2.8","date":"2019-12-19T02:05:05.000Z","updated":"2019-12-19T02:30:43.954Z","comments":true,"path":"2019/12/19/Linux安装redis3.2.8/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装redis3.2.8/","excerpt":"Linux(Centos7.6)安装redis3.2.8 下载 http://download.redis.io/releases","text":"Linux(Centos7.6)安装redis3.2.8 下载 http://download.redis.io/releases 上传到/opt文件夹并解压 1tar -zxvf redis-3.2.8.tar.gz 安装依赖的gcc环境 12rpm -qa | grep gcc #先查询有没有对应的gcc环境yum install gcc make编译安装 12cd /opt/redis-3.2.8make MALLOC=libc &amp; make install 设置redis开机启动 12/opt/redis-3.2.8/utils/install_server.shchkconfig --list #查看开机启动列表 查看redis启动状态 1ps -ef | grep redis 启动和关闭 12service redis_6379 start/redis-server/service redis_6379 restartservice redis_6379 stop redis客户端界面操作 12redis-cli #开启客户端 quit #退出客户端 配置其他信息 12345vim /opt/redis-3.2.8/redis.confprotected-mode no（远程可以访问redis，默认不允许）daemonize yesbind 0.0.0.0(注释绑定端口号)requirepass: 123456 (设置redis密码，默认没有密码) 执行使配置生效 1redis-server /opt/redis-3.2.8/redis.conf","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"Linux命令安装Mysql","slug":"Linux安装mysql5.7.25","date":"2019-12-19T02:05:04.000Z","updated":"2019-12-19T02:30:49.556Z","comments":true,"path":"2019/12/19/Linux安装mysql5.7.25/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装mysql5.7.25/","excerpt":"Linux(Centos7.6)安装mysql-5.7.25 下载 https://downloads.mysql.com/archives/community/","text":"Linux(Centos7.6)安装mysql-5.7.25 下载 https://downloads.mysql.com/archives/community/ 检测是否已经安装mysql 123rpm -qa | grep mysql #如有类似 mysql-libs-5.1.52-1.el6_0.1.x86_64 进行卸载rpm -e mysql-libs-5.1.52-1.el6_0.1.x86_64 #普通删除模式rpm -e --nodeps mysql-libs-5.1.52-1.el6_0.1.x86_64 #强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 检测系统是否有mariadb，若有，同上面步骤卸载 1rpm -qa | grep mariadb 上传文件到服务器 /opt/mysql 解压文件 1tar -zxvf mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz 重命名文件 1mv mysql-5.7.25-linux-glibc2.12-x86_64 mysql-5.7.25 创建mysql用户组和mysql用户(先检查是否存在，若不存在再添加) 1234cat /etc/group | grep mysqlcat /etc/passwd | grep mysqlgroupadd mysqluseradd -r -g mysql mysql #useradd -r 参数表示mysql用户是系统用户，不可用于登录系统 创建data目录 1cd mysql-5.7.25 &amp; mkdir data 将/opt/mysql/mysql-5.7.25的所有者及所属组改为mysql 1chown -R mysql:mysql /opt/mysql/mysql-5.7.25 在/opt/mysql/mysql-5.7.25/support-files目录下创建my_default.cnf 1234567891011[mysqld]sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESbasedir = /opt/mysql/mysql-5.7.25datadir = /opt/mysql/mysql-5.7.25/dataport = 3306socket = /tmp/mysql.sockcharacter-set-server=utf8log-error = /opt/mysql/mysql-5.7.25/data/mysqld.logpid-file = /opt/mysql/mysql-5.7.25/data/mysqld.pid复制文件到/etc目录下cp support-files/my_default.cnf /etc/my.cnf 初始化mysqld 123cd /opt/mysql/mysql-5.7.25./bin/mysqld --initialize --user=mysql --basedir=/opt/mysql/mysql-5.7.25/ --datadir=/opt/mysql/mysql-5.7.25/data//opt/mysql/mysql-5.7.25/data/mysqld.log #查看日志，获取初始化密码 example : 2019-04-08T06:14:29.790033Z 1 [Note] A temporary password is generated for root@localhost: a8?DQir=T+k+ 把启动脚本放到开机初始化目录 1cp support-files/mysql.server /etc/init.d/mysql 启动 1service mysql start 创建软连接使得在任意目录都可以执行mysql命令, 类似于windows桌面快捷方式 1ln -s /opt/mysql/mysql5.7.25/bin/mysql /usr/bin 登录mysql，密码为初始密码 1mysql -u root -p #Enter password: a8?DQir=T+k+ 修改密码：root 1234mysql&gt; set password=password('root');// 添加数据库访问权限（all）mysql&gt; grant all privileges on *.* to root@'%' identified by 'root';mysql&gt; flush privileges; 退出mysql操作界面 1quit 重启mysql生效 1service mysql restart","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Linux命令安装Git","slug":"Linux安装git2.17.0","date":"2019-12-19T02:05:03.000Z","updated":"2019-12-19T02:30:36.514Z","comments":true,"path":"2019/12/19/Linux安装git2.17.0/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装git2.17.0/","excerpt":"Linux(Centos7.6)安装git2.17.0 下载链接：https://github.com/git/git/archive/v2.17.0.tar.gz","text":"Linux(Centos7.6)安装git2.17.0 下载链接：https://github.com/git/git/archive/v2.17.0.tar.gz 解压： 1tar -zxvf v2.17.0.tar.gz 安装依赖： 1yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker 安装依赖时，yum自动安装了Git，需要卸载旧版本Git 1yum remove git #出现提示输入y即可 编译 1cd git-2.17.0 &amp; make prefix=/usr/local/git all 安装Git至/usr/local/git路径 1make prefix=/usr/local/git install 配置环境变量 123vim /etc/profileexport PATH=$PATH:/usr/local/git/binsource /etc/profile 查看安装的git版本，有版本，安装成功 1git --version","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Linux命令安装Maven","slug":"Linux安装maven3.6","date":"2019-12-19T02:05:02.000Z","updated":"2019-12-19T02:30:57.129Z","comments":true,"path":"2019/12/19/Linux安装maven3.6/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装maven3.6/","excerpt":"Linux(Centos7.6)安装maven3.6 下载文件：http://maven.apache.org/download.cgi","text":"Linux(Centos7.6)安装maven3.6 下载文件：http://maven.apache.org/download.cgi 将文件放到/opt文件夹下面, 若没有上传命令先执行: 1yum -y install lrzsz 解压到当前文件夹 1tar zxvf maven*.tar.gz 添加阿里云镜像 123456789vim /opt/maven/config/settings.xml``` ```xml&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置环境变量 1234vim /etc/profileexport MAVEN_HOME=/opt/apache-maven-3.6.3export PATH=$MAVEN_HOME/bin:$PATHsource /etc/profile 校验是否安装成功 1mvn -v\\-version","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"maven3.6","slug":"maven3-6","permalink":"http://yoursite.com/tags/maven3-6/"}]},{"title":"Linux命令安装jdk","slug":"Linux安装jdk1.8","date":"2019-12-19T02:05:01.000Z","updated":"2019-12-19T02:31:07.341Z","comments":true,"path":"2019/12/19/Linux安装jdk1.8/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装jdk1.8/","excerpt":"Linux(Centos7.6)安装jdk1.8yum方式安装","text":"Linux(Centos7.6)安装jdk1.8yum方式安装 查看yum源中是否有相关套件 1yum -y list java* 1yum -y install java-1.8.0-openjdk-devel.x86_64 默认安装路径 /usr/lib/jvm 12345vim /etc/profile export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64 export PATH=.:$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar source /etc/profile 校验是否安装成功 1java -version","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"java8","slug":"java8","permalink":"http://yoursite.com/tags/java8/"}]},{"title":"Follow your Heart, don`t run on gasoline","slug":"firstblog","date":"2019-01-03T03:47:33.144Z","updated":"2019-12-19T01:48:37.757Z","comments":true,"path":"2019/01/03/firstblog/","link":"","permalink":"http://yoursite.com/2019/01/03/firstblog/","excerpt":"","text":"Make a little progress every day and make yourself stronger!","categories":[],"tags":[]}]}