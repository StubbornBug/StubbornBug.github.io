{"meta":{"title":"Footprints of Growth","subtitle":"Note when going straight for success of Mr.Wang","description":"To be or not to be, that is a question.","author":"Mr.Wang","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2019-12-18T08:21:21.000Z","updated":"2019-12-18T08:24:21.258Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-18T08:28:30.000Z","updated":"2019-12-18T08:30:44.633Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"注释规约","slug":"ali05","date":"2020-01-15T01:50:00.000Z","updated":"2020-01-15T02:22:47.659Z","comments":true,"path":"2020/01/15/ali05/","link":"","permalink":"http://yoursite.com/2020/01/15/ali05/","excerpt":"","text":"注释规约 类、类属性、类方法的注释必须使用 Javadoc 规范，使用/内容*/格式，不得使用// xxx 方式。**reason： 增强可读性（工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。） 所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能，对子类的实现要求，或者调用注意事项，也要一并说明 所有的类都必须添加创建者和创建日期 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释。 所有的枚举类型字段必须要有注释，要说明每个数据项的用途 推荐用中文注释把问题说清楚（专有名词与关键字保持英文原文即可） 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 不要轻易注释掉代码。后面可能会恢复此段代码逻辑的需在在上方详细说明；如果永久不用的直接删除即可（仓库会保存历史版本代码）。 要求注释既能够准确反映设计思想和代码逻辑又能够清楚描述业务含义，使自己之后或者别的程序员能够迅速了解代码背后的信息。 注释力求精简准确、表达到位，而不应过多过滥，不必要可以不写注释（遵守命名格式规范的代码是自解释的）。反例： 12// put elephant into fridgeput(elephant, fridge); 特殊注释标记并注意及时（通过标记扫描）处理这些标记。线上故障有时候就是来源于这些标记处的代码。知识点：TODO和FIXME1） 待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）&emsp;&emsp;表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）&emsp;&emsp;在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。","categories":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/categories/编码规约/"}],"tags":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/tags/编码规约/"}]},{"title":"控制语句","slug":"ali04","date":"2020-01-10T12:50:00.000Z","updated":"2020-01-10T13:59:08.778Z","comments":true,"path":"2020/01/10/ali04/","link":"","permalink":"http://yoursite.com/2020/01/10/ali04/","excerpt":"","text":"控制语句 在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。reason: 有确定性的退出程序，不然以后程序会执行到哪个地方自己都搞不清楚 当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断reason：根本不会进入语句体，直接NPE（NullPointerException） 在 if/else/for/while/do 语句中必须使用大括号(哪怕只有一行逻辑代码) 在高并发场景中，避免使用”等于”判断作为中断或退出的条件（使用大于或小于的区间判断条件来代替）reason: 如果并发控制没有处理好，容易产生等值判断被“击穿”的情况 栗子：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。 表达异常的分支时，少用 if-else 方式reason: 后期代码维护困难正例： 12345if (condition) &#123; ... return obj;&#125;// 接着写 else 的业务逻辑代码 if else 语句不要超过 3 层（超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现）知识点：卫语句即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断分支嵌套的问题 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性 不要在其它表达式（尤其是条件表达式）中插入赋值语句（赋值语句单独占一行来执行）。reason: 提高代码可读性反例： 123456public Lock getLock(boolean fair) &#123; // 算术表达式中出现赋值操作，容易忽略 count 值已经被改变 threshold = (count = Integer.MAX_VALUE) - 1; // 条件表达式中出现赋值操作，容易误认为是 sync==fair return (sync = fair) ? new FairSync() : new NonfairSync();&#125; 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外） 避免采用取反逻辑运算符reason：提高代码可读性正例：使用 if (x &lt; 628) 来表达 x 小于 628。反例：使用 if (!(x &gt;= 628)) 来表达 x 小于 628。 接口入参保护，这种场景常见的是用作批量操作的接口todo： 参数校验： 需要参数校验得情形：1） 调用频次低的方法。2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。3） 需要极高稳定性和可用性的方法。4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。5） 敏感权限入口。 不需要参数校验得情形：1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。","categories":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/categories/编码规约/"}],"tags":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/tags/编码规约/"}]},{"title":"代码格式","slug":"ali03","date":"2020-01-10T11:20:00.000Z","updated":"2020-01-10T12:41:24.906Z","comments":true,"path":"2020/01/10/ali03/","link":"","permalink":"http://yoursite.com/2020/01/10/ali03/","excerpt":"","text":"代码格式 如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块：1） 左大括号前不换行。2） 左大括号后换行。3） 右大括号前换行。4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格 if/for/while/switch/do 等保留字与括号之间都必须加空格。 任何二目、三目运算符的左右两边都需要加一个空格 采用 4 个空格缩进，禁止使用 tab 字符reason: 国标是4个空格，一个tab字符不一定是四个空格，若使用tab，必须对编译器设置：&emsp;&emsp;&emsp;&emsp;idea设置方式：todo：code： 1234567891011121314151617181920public class FormatClass &#123; public static void main(String[] args) &#123; // 缩进 4 个空格 String say = \"hello\"; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println(\"world\"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(\"ok\"); // 在右大括号后直接结束，则必须换行 &#125; &#125; &#125;&#125; 注释的双斜线与注释内容之间有且仅有一个空格 在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开正例：long first = 1000000000000L;int second = (int)first + 2; 单行字符数限制不超过 120 个，超出需要换行1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进。2）运算符与下文一起换行。3）方法调用的点符号与下文一起换行。4）方法调用中的多个参数需要换行时，在逗号后进行。5）在括号前不要换行code: 123456789101112131415// 正例StringBuilder sb = new StringBuilder();// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行sb.append(\"Jack\").append(\"Ma\")... .append(\"alibaba\")... .append(\"alibaba\")... .append(\"alibaba\");// 反例StringBuilder sb = new StringBuilder();// 超过 120 个字符的情况下，不要在括号前换行sb.append(\"Jack\").append(\"Ma\")...append (\"alibaba\");// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX); 方法参数在定义和传入时，多个参数逗号后边必须加空格正例：method(args1, args2, args3) IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 Windows 格式。reason: 很多windows格式会有问题，比如记事本开头添加0xefbbbf（十六进制）的字符,会导致文本问题配置方式：todo: 单个方法的总行数不超过 80 行(除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过80行, 建议把独立的逻辑抽取出来形成单独的方法，清晰明了) 没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。reason: 并不好看；变量比较多的情况下会非常麻烦；正例： 1234int one = 1;long two = 2L;float three = 3F;StringBuilder sb = new StringBuilder(); 不同逻辑、不同语义、不同业务的代码之间插入一个（仅仅一行就够了）空行分隔开来以提升可读性。","categories":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/categories/编码规约/"}],"tags":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/tags/编码规约/"}]},{"title":"常量定义","slug":"ali02","date":"2020-01-10T10:40:00.000Z","updated":"2020-01-10T10:58:24.960Z","comments":true,"path":"2020/01/10/ali02/","link":"","permalink":"http://yoursite.com/2020/01/10/ali02/","excerpt":"","text":"常量定义 不允许任何魔法值（即未经预先定义的常量）直接出现在代码中反例：String key = “Id#taobao_” + tradeId;&emsp;&emsp;&emsp;cache.put(key, value);&emsp;&emsp;&emsp;代码复制时容易漏掉下划线，导致缓存击穿而出现问题 在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解 不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。 根据常量的复用层次确定常量类应放的位置1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。2） 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。反例：易懂变量也要统一定义成应用内共享常量，两位工程师在两个类中分别定义了“YES”的变量：类 A 中：public static final String YES = “yes”;类 B 中：public static final String YES = “y”;A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。3） 子工程内部共享常量：即在当前子工程的 constant 目录下。4） 包内共享常量：即在当前包下单独的 constant 目录下。5） 类内共享常量：直接在类内部 private static final 定义。知识点：一方库：todo： 如果变量值仅在一个固定范围内变化用 enum 类型来定义 12345678910111213// **存在名称之外的延伸属性**应使用 enum 类型，下面代码括号里的数字就是延伸信息，表示一年中的第几个季节public enum SeasonEnum &#123; SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4); private int seq; SeasonEnum(int seq) &#123; this.seq = seq; &#125; public int getSeq() &#123; return seq; &#125;&#125;","categories":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/categories/编码规约/"}],"tags":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/tags/编码规约/"}]},{"title":"命名风格","slug":"ali01","date":"2020-01-10T08:18:00.000Z","updated":"2020-01-10T10:40:39.995Z","comments":true,"path":"2020/01/10/ali01/","link":"","permalink":"http://yoursite.com/2020/01/10/ali01/","excerpt":"命名风格 命名均不能以下划线（）或美元符号($)开始，也不能以下划线（）或美元符号($)结束。反例：name / __name / $name / name / name$ / name__reason：python下划线开头是内部变量.","text":"命名风格 命名均不能以下划线（）或美元符号($)开始，也不能以下划线（）或美元符号($)结束。反例：name / __name / $name / name / name$ / name__reason：python下划线开头是内部变量. 严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。正例：renminbi / alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3reason: 正确的英文拼写和语法可以让阅读者易于理解，避免歧义. 中文拼音有同音字（Pingfen：评分，平分），汉字会有编码问题。 类名使用 UpperCamelCase 风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID 等。正例：JavaServerlessPlatform / UserDO / XmlService / TcpUdpDeal / TaPromotion 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。 类型与中括号紧挨相连来表示数组。正例：定义整形数组 int[] arrayDemoreason: 便于阅读，一下就知道是数组。 POJO 类中布尔类型变量都不要加 is 前缀，否则部分框架解析会引起序列化错误。todo: 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils 避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。reason：子类、父类成员变量名相同，即使是 public 类型的变量也是能够通过编译，而局部变量在同一方法内的不同代码块中同名也是合法的，但是要避免使用。对于非 setter/getter 的参数名称也要避免与成员变量名称相同。code: 杜绝完全不规范的缩写reason：严重降低代码的可读性 任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。正例：在 JDK 中，表达原子更新的类名为：AtomicReferenceFieldUpdaterreason: 实现代码自解释 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度reason: nameList 和 listName 一个表示名字集合，一个表示集合名称，很容易混淆。 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。正例：public class OrderFactory;public class LoginProxy;public class ResourceObserver;reason:有利于阅读者快速理解架构设计理念 接口类中的方法和属性不要加任何修饰符号，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量正例：接口方法签名 void commit();&emsp;&emsp;&emsp;接口基础常量 String COMPANY = “edutech”;&emsp;&emsp;&emsp;JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。reason:接口变量默认省略 public static final，接口方法默认省略 public abstract 对于 Service 和 DAO 类，基于 SOA（Service-Oriented Architecture） 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别；如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）正例：CacheServiceImpl 实现 CacheService 接口；&emsp;&emsp;&emsp;AbstractTranslator 实现 Translatable 接口； 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON 各层命名规约 Service/DAO 层方法命名规约1） 获取单个对象的方法用 get 做前缀。2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。3） 获取统计值的方法用 count 做前缀。4） 插入的方法用 save/insert 做前缀。5） 删除的方法用 remove/delete 做前缀。6） 修改的方法用 update 做前缀。 领域模型命名规约1） 数据对象：xxxDO，xxx 即为数据表名。2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。3） 展示对象：xxxVO，xxx 一般为网页名称。4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。知识点：领域模型是一个分析模型，帮助系统分析人员、用户认识现实业务的工具，描述的是业务中涉及到的实体及其相互之间的关系，它是需求分析的产物，与问题域相关。知识点：DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。AO (Application Object) :应用对象,在 Web 层与 Service 层之间抽象的复用对象模型,极为贴近展示层,复用度不高。POJO 是 DO / DTO / BO / VO 的统称， 命名时禁止使用XXPOJO。","categories":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/categories/编码规约/"}],"tags":[{"name":"编码规约","slug":"编码规约","permalink":"http://yoursite.com/tags/编码规约/"}]},{"title":"策略模式","slug":"strategy-pattern","date":"2020-01-10T07:16:00.000Z","updated":"2020-01-10T08:02:40.887Z","comments":true,"path":"2020/01/10/strategy-pattern/","link":"","permalink":"http://yoursite.com/2020/01/10/strategy-pattern/","excerpt":"设计模式之策略模式定义&emsp;&emsp;策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。 了解&emsp;&emsp;策略模式实用性强、扩展性好，在软件开发中得以广泛使用，是使用频率较高的设计模式之一&emsp;&emsp;策略模式将原本庞大的算法类的职责进行分解，将算法的定义和使用分离。我们可以定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里，每一个封装算法的类我们都可以称之为一种策略(Strategy)，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做规则的定义，而每种算法则对应于一个具体策略类。&emsp;&emsp;策略模式的主要目的是将算法的定义与使用分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。","text":"设计模式之策略模式定义&emsp;&emsp;策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。 了解&emsp;&emsp;策略模式实用性强、扩展性好，在软件开发中得以广泛使用，是使用频率较高的设计模式之一&emsp;&emsp;策略模式将原本庞大的算法类的职责进行分解，将算法的定义和使用分离。我们可以定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里，每一个封装算法的类我们都可以称之为一种策略(Strategy)，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做规则的定义，而每种算法则对应于一个具体策略类。&emsp;&emsp;策略模式的主要目的是将算法的定义与使用分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，使用算法的环境类针对抽象策略类进行编程，符合“依赖倒转原则”。在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。 结构图 Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略(但最终选择一种)。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。环境类是需要使用算法的类。在一个系统中可以存在多个环境类，它们可能需要重用一些相同的算法。 Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。 ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。 典型代码1234// 抽象策略类abstract class AbstractStrategy &#123; public abstract void algorithm(); //声明抽象算法&#125; 1234567// 具体策略类class ConcreteStrategyA extends AbstractStrategy &#123; //算法的具体实现 public void algorithm() &#123; //算法A &#125;&#125; 12345678910111213// 环境类class Context &#123;private AbstractStrategy strategy; //维持一个对抽象策略类的引用 public void setStrategy(AbstractStrategy strategy) &#123; this.strategy= strategy; &#125; //调用策略类中的算法 public void algorithm() &#123; strategy.algorithm(); &#125;&#125; 12345678// 客户端类……Context context = new Context();AbstractStrategy strategy;strategy = new ConcreteStrategyA(); //可在运行时指定类型context.setStrategy(strategy);context.algorithm();…… 示例 典型应用(Java SE的容器布局管理) 12345678910public class Container extends Component &#123; …… LayoutManager layoutMgr; …… public void setLayout(LayoutManager mgr) &#123; layoutMgr = mgr; …… &#125; ……&#125; 总结&emsp;&emsp;策略模式用于算法的自由切换和扩展，它是应用较为广泛的设计模式之一。策略模式对应于解决某一问题的一个算法族，允许用户从该算法族中任选一个算法来解决某一问题，同时可以方便地更换算法或者增加新的算法。只要涉及到算法的封装、复用和切换都可以考虑使用策略模式。 优点 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。 策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”；而且使用继承无法实现算法或行为在程序运行时的动态切换。 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。 适用场景 一个系统需要动态地在几种算法中选择一种，根据“里氏代换原则”和面向对象的多态性，客户端可以通过抽象算法类用一致性的方式使用任何一个具体算法类。 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。 code1234567891011121314151617181920/** * @author Wangzy * @Description: 客户类 * @date 14:23 2020/1/10 */public class Client &#123; public static void main(String[] args) &#123; // 创建环境类，客户端直接与其交互 MovieTicket movieTicket = new MovieTicket(); double price = 60.00; System.out.println(\"原票价:\" + price); movieTicket.setPrice(price); System.out.println(\"设置打折方式!\"); movieTicket.setStrategy(new ChildrenDiscount()); System.out.println(\"儿童票：\" + movieTicket.getPrice()); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * @author Wangzy * @Description: 环境类 * @date 14:26 2020/1/10 */public class MovieTicket &#123; private double price; // 注入抽象策略类（维持抽象策略类的引用） private Discount discount; /** * @Description: 设置具体策略 * @author Wangzy * @date 14:33 2020/1/10 */ public void setStrategy(Discount discount) &#123; this.discount = discount; &#125; public void setPrice(double price) &#123; this.price = price; &#125; /** * @Description: 获取折后价格 * @author Wangzy * @date 14:36 2020/1/10 */ public double getPrice() &#123; return this.discount.calculate(this.price); &#125;&#125; 123456789/** * @author Wangzy * @Description: 抽象策略类 * @date 14:26 2020/1/10 */abstract class Discount &#123; abstract double calculate(double price);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author Wangzy * @Description: 具体策略类（儿童票打折方案） * @date 14:30 2020/1/10 */public class ChildrenDiscount extends Discount &#123; @Override double calculate(double price) &#123; if (price &gt;= 20.00) &#123; return price - 10.00; &#125; return price; &#125;&#125;/** * @author Wangzy * @Description: 具体策略类（学生票打折方案） * @date 14:28 2020/1/10 */public class StudentDiscount extends Discount &#123; @Override double calculate(double price) &#123; return price * 0.8; &#125;&#125;/** * @author Wangzy * @Description: 具体策略类（VIP打折方案） * @date 14:29 2020/1/10 */public class VIPDiscount extends Discount &#123; @Override double calculate(double price) &#123; return price * 0.5; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7818983https://blog.csdn.net/lovelion/article/details/7819136https://blog.csdn.net/lovelion/article/details/7819216https://blog.csdn.net/lovelion/article/details/7819266","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"行为型模式","slug":"行为型模式","permalink":"http://yoursite.com/tags/行为型模式/"}]},{"title":"代理模式","slug":"proxy-pattern","date":"2020-01-09T01:42:00.000Z","updated":"2020-01-09T03:37:26.961Z","comments":true,"path":"2020/01/09/proxy-pattern/","link":"","permalink":"http://yoursite.com/2020/01/09/proxy-pattern/","excerpt":"设计模式之代理模式定义&emsp;&emsp;代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 了解&emsp;&emsp;代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理、智能引用代理等，它们应用于不同的场合，满足用户的不同需求。&emsp;&emsp;代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。&emsp;&emsp;为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。&emsp;&emsp;通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。&emsp;&emsp;为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。","text":"设计模式之代理模式定义&emsp;&emsp;代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 了解&emsp;&emsp;代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理、智能引用代理等，它们应用于不同的场合，满足用户的不同需求。&emsp;&emsp;代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。&emsp;&emsp;为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。&emsp;&emsp;通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。&emsp;&emsp;为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。 结构图&emsp;&emsp;代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层 Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。 Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。 RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。 典型代码12345// 抽象主题类abstract class Subject&#123; public abstract void Request();&#125; 123456789// 真实主题类class RealSubject extends Subject&#123; @Override public void Request() &#123; //业务方法具体实现代码 &#125;&#125; 1234567891011121314151617181920212223// 代理类class Proxy extends Subject&#123; private RealSubject realSubject = new RealSubject(); //维持一个对真实主题对象的引用 public void PreRequest() &#123; …... &#125; @Override public void Request() &#123; PreRequest(); realSubject.Request(); //调用真实主题对象的方法 PostRequest(); &#125; public void PostRequest() &#123; …… &#125;&#125; 示例 远程代理&emsp;&emsp;远程代理(Remote Proxy)是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。栗子：&emsp;&emsp;客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。&emsp;&emsp;在基于.NET平台的分布式技术，例如DCOM(Distribute Component Object Model，分布式组件对象模型)、Web Service中，都应用了远程代理模式. 虚拟代理&emsp;&emsp;虚拟代理(Virtual Proxy)也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。 &emsp;&emsp;由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。通常在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。&emsp;&emsp;当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。&emsp;&emsp;以上两种情况的虚拟代理都是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。 缓冲代理&emsp;&emsp;缓冲代理(Cache Proxy)也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而可以避免某些方法的重复执行，优化系统性能。 总结&emsp;&emsp;代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。代理模式类型较多，其中远程代理、虚拟代理、保护代理等在软件开发中应用非常广泛。 优点 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。 缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。 适用场景 当客户端对象需要访问远程主机中的对象时可以使用远程代理。 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。 code1234567891011121314151617/** * @author Wangzy * @Description: 客户端类 * @date 17:25 2020/1/8 */public class Client &#123; public static void main(String[] args) &#123; Searcher searcher = new ProxySearcher(); // 通过代理类操作真实主题类 String search = searcher.search(\"test\", \"abc\"); System.out.println(search); &#125;&#125; 1234567891011121314/** * @author Wangzy * @Description: 抽象代理类（搜索对象） * @date 17:26 2020/1/8 */abstract class Searcher &#123; /** * @Description: 搜索功能 * @author Wangzy * @date 17:27 2020/1/8 */ abstract String search(String userid, String keyword);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @author Wangzy * @Description: 代理主题角色（代理查询对象） * @date 17:30 2020/1/8 */public class ProxySearcher extends Searcher &#123; private RealSearcher realSearcher = new RealSearcher(); private boolean validate(String userid) &#123; System.out.println(\"在数据库中验证用户'\" + userid + \"'是否是合法用户!\"); if (\"test\".equals(userid)) &#123; System.out.println(\"\" + userid + \"登录成功！\"); return true; &#125; else &#123; return false; &#125; &#125; @Override public String search(String userid, String keyword) &#123; // 身份校验 boolean validate = this.validate(userid); // ============================================================================================================= String searchResult; // 信息查询 if (validate) &#123; searchResult = this.realSearcher.search(userid, keyword); &#125; else &#123; return \"登录失败!\"; &#125; // ============================================================================================================= // 日志记录 this.log(userid); return searchResult; &#125; private void log(String userid) &#123; System.out.println(\"更新数据库，用户\" + userid + \"查询次数加1!\"); &#125;&#125; 12345678910111213/** * @author Wangzy * @Description: 真实主题对象（真实查询对象） * @date 17:29 2020/1/8 */public class RealSearcher extends Searcher &#123; @Override String search(String userid, String keyword) &#123; System.out.println(\"用户\" + userid + \"用关键字：'\" + keyword + \"'查黄色片段!\"); return \"簧片！\"; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/8227953https://blog.csdn.net/lovelion/article/details/8228042https://blog.csdn.net/lovelion/article/details/8228132https://blog.csdn.net/lovelion/article/details/8228156","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://yoursite.com/tags/结构型模式/"}]},{"title":"享元模式","slug":"flyweight-pattern","date":"2020-01-08T02:00:00.000Z","updated":"2020-01-08T06:22:10.828Z","comments":true,"path":"2020/01/08/flyweight-pattern/","link":"","permalink":"http://yoursite.com/2020/01/08/flyweight-pattern/","excerpt":"设计模式之享元模式定义&emsp;&emsp;享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。 了解&emsp;&emsp;当一个软件系统在运行时产生的对象数量太多，将导致运行代价过高，带来系统性能下降等问题。比如在一个文本字符串中存在很多重复的字符，如果每一个字符都用一个单独的对象来表示，将会占用非常多的内存空间。&emsp;&emsp;享元模式通过共享技术实现相同或相似对象的重用。仍拿字符串为例，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例，在享元模式中，存储这些共享实例对象的地方称为享元池(Flyweight Pool)。我们可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，需要时再从享元池取出。&emsp;&emsp;享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。如字符串中字符的内容，不会随外部环境的变化而变化，无论在任何环境下字符“a”始终是“a”，都不会变成“b”； 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。如：字符串中字符的颜色，可以在不同的地方有不同的颜色，例如有的“a”是红色的，有的“a”是绿色的，字符的大小也是如此，有的“a”是五号字，有的“a”是四号字。而且字符的颜色和大小是两个独立的外部状态，它们可以独立变化，相互之间没有影响，客户端可以在使用时将外部状态注入享元对象中。 &emsp;&emsp;因此可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，需要的时候就将对象从享元池中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份。","text":"设计模式之享元模式定义&emsp;&emsp;享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。 了解&emsp;&emsp;当一个软件系统在运行时产生的对象数量太多，将导致运行代价过高，带来系统性能下降等问题。比如在一个文本字符串中存在很多重复的字符，如果每一个字符都用一个单独的对象来表示，将会占用非常多的内存空间。&emsp;&emsp;享元模式通过共享技术实现相同或相似对象的重用。仍拿字符串为例，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例，在享元模式中，存储这些共享实例对象的地方称为享元池(Flyweight Pool)。我们可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，需要时再从享元池取出。&emsp;&emsp;享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。如字符串中字符的内容，不会随外部环境的变化而变化，无论在任何环境下字符“a”始终是“a”，都不会变成“b”； 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。如：字符串中字符的颜色，可以在不同的地方有不同的颜色，例如有的“a”是红色的，有的“a”是绿色的，字符的大小也是如此，有的“a”是五号字，有的“a”是四号字。而且字符的颜色和大小是两个独立的外部状态，它们可以独立变化，相互之间没有影响，客户端可以在使用时将外部状态注入享元对象中。 &emsp;&emsp;因此可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，需要的时候就将对象从享元池中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份。 结构图&emsp;&emsp;享元模式一般结合工厂模式一起使用，在它的结构图中包含了一个享元工厂类： Flyweight（抽象享元类）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。FlyweightFactory（享元工厂类）：结合工厂模式进行设计，享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合)；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例，如果不存在的话,创建返回一个新的实例并将其存储在享元池中。 典型代码123456789101112131415161718// 享元工厂类class FlyweightFactory &#123; //定义一个HashMap用于存储享元对象，实现享元池 private HashMap flyweights = newHashMap(); public Flyweight getFlyweight(String key)&#123; //如果对象存在，则直接从享元池获取 if(flyweights.containsKey(key))&#123; return(Flyweight)flyweights.get(key); &#125; //如果对象不存在，先创建一个新的对象添加到享元池中，然后返回 else &#123; Flyweight fw = newConcreteFlyweight(); flyweights.put(key,fw); return fw; &#125; &#125;&#125; &emsp;&emsp;在享元模式中引入了享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。 1234567891011121314// 抽象享元类class Flyweight &#123; //内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的 private String intrinsicState; public Flyweight(String intrinsicState) &#123; this.intrinsicState=intrinsicState; &#125; //外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象，在每一次调用时也可以传入不同的外部状态 public void operation(String extrinsicState) &#123; ...... &#125;&#125; 示例 单纯享元模式和复合享元模式&emsp;&emsp;标准的享元模式既包含具体享元类，也包含非共享具体享元类，也可以有另外两种特殊的享元模式： 单纯享元模式&emsp;&emsp;单纯享元模式只包含可以共享的具体享元类： 复合享元模式&emsp;&emsp;将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成可共享的单纯享元对象。&emsp;&emsp;复合享元模式可以确保复合享元类CompositeConcreteFlyweight中所包含的每个单纯享元类ConcreteFlyweight都具有相同的外部状态，而这些单纯享元的内部状态往往可以不同。如果希望为多个内部状态不同的享元对象设置相同的外部状态，可以考虑使用复合享元模式。 与其他设计模式联用 享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，一般使用简单工厂模式来生成享元对象； 一个系统通常只维护一个享元工厂，因此可以使用单例模式进行享元工厂类的设计； 可以结合组合模式形成复合享元模式，统一对（不同内部状态的）多个享元对象设置外部状态； String类&emsp;&emsp;如果每次执行类似String str1=”abcd”的操作时都创建一个新的字符串对象将导致内存开销很大，因此如果第一次创建了内容为”abcd”的字符串对象str1，下一次再创建内容相同的字符串对象str2时会将它的引用指向”abcd”，不会重新分配内存空间，从而实现了”abcd”在内存中的共享。 总结&emsp;&emsp;当系统中存在大量相同或者相似的对象时，享元模式是一种比较好的解决方案，它通过共享技术实现相同或相似的细粒度对象的复用，从而节约了内存空间，提高了系统性能。相比其他结构型设计模式，享元模式的使用频率并不算太高，但是作为一种以“节约内存，提高性能”为出发点的设计模式，它在软件开发中还是得到了一定程度的应用。 优点 可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。 缺点 享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。 适用场景 一个系统有大量相同或者相似的对象，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。 code123456789101112131415161718192021222324252627282930/** * @author Wangzy * @Description: 客户端类 * @date 11:23 2020/1/8 */@SuppressWarnings(\"ALL\")public class Client &#123; public static void main(String[] args) &#123; // 创建享元工厂类 IgoChessmanFactory factory = IgoChessmanFactory.getFactory(); // 创建享元对象 IgoChessman igoChessman = factory.getIgoChessman(\"black\"); IgoChessman igoChessman1 = factory.getIgoChessman(\"black\"); IgoChessman igoChessman2 = factory.getIgoChessman(\"white\"); IgoChessman igoChessman3 = factory.getIgoChessman(\"white\"); System.out.println(igoChessman == igoChessman1); System.out.println(igoChessman2 == igoChessman3); igoChessman.display(new Coordinates(1,1)); igoChessman1.display(new Coordinates(2,1)); igoChessman2.display(new Coordinates(1,3)); igoChessman3.display(new Coordinates(2,2)); &#125;&#125; 1234567891011121314151617181920212223/** * @author Wangzy * @Description: 抽象享元类 * @date 11:24 2020/1/8 */abstract class IgoChessman &#123; /** * @Description: 提供对象的内部数据（在此指颜色） * @author Wangzy * @date 13:32 2020/1/8 */ abstract String getColor(); /** * @Description: （设置外部状态）coordinate参数为客户端传入的外部状态 * @author Wangzy * @date 13:28 2020/1/8 */ void display(Coordinates coordinates) &#123; System.out.println(\"在（\" + coordinates.getX() + \", \" + coordinates.getY() + \"）显示\" + this.getColor() + \"棋子!\"); &#125;&#125; 12345678910111213141516171819202122232425/** * @author Wangzy * @Description: 具体享元类（黑色棋子） * @date 11:29 2020/1/8 */public class BlackIgoChessman extends IgoChessman &#123; @Override String getColor() &#123; return \"黑色\"; &#125;&#125;/** * @author Wangzy * @Description: 具体享元类（白色棋子） * @date 11:29 2020/1/8 */public class WhiteIgoChessman extends IgoChessman &#123; @Override String getColor() &#123; return \"白色\"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Hashtable;/** * @author Wangzy * @Description: 享元工厂类 * @date 11:30 2020/1/8 */public class IgoChessmanFactory &#123; // 饿汉式单例模式创建享元工厂对象 private static IgoChessmanFactory factory = new IgoChessmanFactory(); // hashtable充当享元池 private static Hashtable&lt;String, Object&gt; hashtable; private IgoChessmanFactory() &#123; hashtable = new Hashtable(); // 提前创建享元对象并放入享元池 IgoChessman blackIgoChessman = new BlackIgoChessman(); hashtable.put(\"black\", blackIgoChessman); IgoChessman whiteIgoChessman = new WhiteIgoChessman(); hashtable.put(\"white\", whiteIgoChessman); &#125; public static IgoChessmanFactory getFactory() &#123; return factory; &#125; /** * @Description: 创建享元对象 * @author Wangzy * @date 11:35 2020/1/8 */ public static IgoChessman getIgoChessman(String color) &#123; return (IgoChessman) hashtable.get(color); &#125;&#125; 12345678910111213141516171819202122232425262728293031/** * @author Wangzy * @Description: 外部状态类（棋子坐标） * @date 13:25 2020/1/8 */public class Coordinates &#123; private Integer x; private Integer y; public Coordinates(Integer x, Integer y) &#123; this.x = x; this.y = y; &#125; public Integer getX() &#123; return x; &#125; public void setX(Integer x) &#123; this.x = x; &#125; public Integer getY() &#123; return y; &#125; public void setY(Integer y) &#123; this.y = y; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7667781https://blog.csdn.net/lovelion/article/details/7667810https://blog.csdn.net/lovelion/article/details/7667839https://blog.csdn.net/lovelion/article/details/7667860https://blog.csdn.net/lovelion/article/details/7667901","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://yoursite.com/tags/结构型模式/"}]},{"title":"装饰模式","slug":"decorate-pattern","date":"2020-01-06T09:26:00.000Z","updated":"2020-01-06T11:07:40.959Z","comments":true,"path":"2020/01/06/decorate-pattern/","link":"","permalink":"http://yoursite.com/2020/01/06/decorate-pattern/","excerpt":"设计模式之装饰模式定义&emsp;&emsp;装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 了解&emsp;&emsp;根据“合成复用原则”，在实现功能复用时，我们要多用关联，少用继承, 我们可以将要增强的方法抽取出来，封装在一个独立的类中，在这个类中定义（关联）一个Component类型的对象，通过调用Component的base()方法来实现对象最基本的功能，同时再通过addBehavior()方法对基本构件的功能进行增强；&emsp;&emsp;根据“里氏代换原则”，程序运行过程中，我们只要向这个独立的类（装饰器或装饰类）中注入具体的Component子类的对象即可实现功能的扩展。&emsp;&emsp;装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为，是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。","text":"设计模式之装饰模式定义&emsp;&emsp;装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。 了解&emsp;&emsp;根据“合成复用原则”，在实现功能复用时，我们要多用关联，少用继承, 我们可以将要增强的方法抽取出来，封装在一个独立的类中，在这个类中定义（关联）一个Component类型的对象，通过调用Component的base()方法来实现对象最基本的功能，同时再通过addBehavior()方法对基本构件的功能进行增强；&emsp;&emsp;根据“里氏代换原则”，程序运行过程中，我们只要向这个独立的类（装饰器或装饰类）中注入具体的Component子类的对象即可实现功能的扩展。&emsp;&emsp;装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为，是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。 结构图&emsp;&emsp;为了让系统具有更好的灵活性和可扩展性，通常会定义一个抽象装饰类，而将具体的装饰类作为它的子类。 Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。 Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 &emsp;&emsp;由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。 典型代码12345678910111213141516// 抽象装饰类class Decorator implements Component&#123; private Component component; //维持一个对抽象构件对象的引用 public Decorator(Component component) //注入一个抽象构件类型的对象 &#123; this.component=component; &#125; public void operation() &#123; component.operation(); //调用原有业务方法 &#125;&#125; &emsp;&emsp;在Decorator中并未真正实现operation()方法，而只是调用原有component对象的operation()方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。 123456789101112131415161718192021// 具体装饰类（继承operation()方法并根据需要进行扩展）class ConcreteDecorator extends Decorator&#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; public void operation() &#123; super.operation(); //调用原有业务方法 addedBehavior(); //调用新增业务方法 &#125; //新增业务方法 public void addedBehavior() &#123; …… &#125;&#125; &emsp;&emsp;由于在抽象装饰类Decorator中注入的是Component类型的对象，因此我们可以将一个具体构件对象注入其中，再通过具体装饰类来进行装饰；此外，我们还可以将一个已经装饰过的Decorator子类的对象再注入其中进行多次装饰，从而对原有功能的多次扩展。&emsp;&emsp;子类继承了父类，若父类的构造方法没有重载那么，子类的构造方法也不需要通过super调用父类构造方法。一个类中如果构造方法重写了并且带了参数，那么这个类的原来系统默认的无参构造方法便消失。由此，若一个父类中只有一个带参数的构造方法，那么在写其子类的构造方法时必须先通过super调用父类的构造方法才能完成子类的构造方法而且super只能写在子类构造方法体内的第一行。 示例 &emsp;&emsp;如果需要在原有系统中增加一个新的具体构件类或者新的具体装饰类，无须修改现有类库代码，只需将它们分别作为抽象构件类或者抽象装饰类的子类即可。 透明装饰模式与半透明装饰模式&emsp;&emsp;装饰模式虽好，但存在一个问题。如果客户端希望单独调用具体装饰类新增的方法，而不想通过抽象构件中声明的方法来调用新增方法时将有问题。栗子：12345678910111213141516//抽象装饰类class Decorator implements Document&#123; private Document document; public Decorator(Document document) &#123; this. document = document; &#125; public void display() &#123; document.display(); &#125;&#125; 1234567891011121314//具体装饰类class Approver extends Decorator&#123; public Approver(Document document) &#123; super(document); System.out.println(\"增加审批功能！\"); &#125; public void approve() &#123; System.out.println(\"审批文件！\"); &#125;&#125; 123456Document doc; //使用抽象构件类型定义doc = new PurchaseRequest();Approver newDoc; //使用具体装饰类型定义newDoc = new Approver(doc);newDoc.display();//调用原有业务方法newDoc.approve();//调用新增业务方法 &emsp;&emsp;如果newDoc也使用Document类型来定义，将导致客户端无法调用新增业务方法approve()，因为在抽象构件类Document中没有对approve()方法的声明。也就是说，在客户端无法统一对待装饰之前的具体构件对象和装饰之后的构件对象。&emsp;&emsp;在实际使用过程中，由于新增行为可能需要单独调用，因此这种形式的装饰模式也经常出现，这种装饰模式被称为半透明(Semi-transparent)装饰模式，而标准的装饰模式是透明(Transparent)装饰模式。 透明装饰模式&emsp;&emsp;在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。123Component c, c1; //使用抽象构件类型定义对象c = new ConcreteComponent()；c1 = new ConcreteDecorator (c)； 1234567……Component component,componentSB,componentBB; //全部使用抽象构件定义component = new Window();componentSB = new ScrollBarDecorator(component);componentBB = new BlackBorderDecorator(componentSB);componentBB.display();…… &emsp;&emsp;透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象。在实现透明装饰模式时，要求具体装饰类的operation()方法覆盖抽象装饰类的operation()方法，除了调用原有对象的operation()外还需要调用新增的addedBehavior()方法来增加新行为 半透明装饰模式&emsp;&emsp;客户端希望单独调用新增的方法时，不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式，也就是说，对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。123456……Document doc; //使用抽象构件类型定义doc = new PurchaseRequest();Approver newDoc; //使用具体装饰类型定义newDoc = new Approver(doc);…… &emsp;&emsp;半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。在实现半透明的装饰模式时，我们只需在具体装饰类中增加一个独立的addedBehavior()方法来封装相应的业务处理，由于客户端使用具体装饰类型来定义装饰后的对象，因此可以（直接）单独调用addedBehavior()方法来扩展系统功能。 注意事项 尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。 尽量保持具体构件类ConcreteComponent是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。 如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。 栗子： 总结&emsp;&emsp;装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在JavaIO中的输入流和输出流的设计、javax.swing包中一些图形界面构件功能的增强等地方都运用了装饰模式。 优点 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。 缺点 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。 适用场景 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。 code123456789101112131415161718192021/** * @author Wangzy * @Description: 客户类 * @date 15:56 2020/1/6 */public class Client &#123; public static void main(String[] args) &#123; Component component = new Window(); // 装饰（添加滚动条） Component scrollBarComponent = new ScrollBarDecorator(component); // 二次装饰（添加黑色边框） Component scrollBarAndBlackBorderComponent = new BlackBorderDecorator(scrollBarComponent);// scrollBarComponent.display(); scrollBarAndBlackBorderComponent.display();// System.out.println(component == scrollBarComponent);// System.out.println(scrollBarComponent == scrollBarAndBlackBorderComponent); &#125;&#125; 1234567891011import javax.swing.plaf.nimbus.AbstractRegionPainter;/** * @author Wangzy * @Description: 抽象构件类 * @date 15:56 2020/1/6 */abstract class Component &#123; abstract void display();&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * @author Wangzy * @Description: 具体构件类（列表框） * @date 15:58 2020/1/6 */public class ListBox extends Component &#123; @Override void display() &#123; System.out.println(\"显示列表框!\"); &#125;&#125;/** * @author Wangzy * @Description: 具体构件类（文本框） * @date 15:58 2020/1/6 */public class TextBox extends Component &#123; @Override void display() &#123; System.out.println(\"显示文本框!\"); &#125;&#125;/** * @author Wangzy * @Description: 具体构件类（窗体） * @date 15:58 2020/1/6 */public class Window extends Component &#123; @Override void display() &#123; System.out.println(\"显示窗体!\"); &#125;&#125; 12345678910111213141516171819/** * @author Wangzy * @Description: 抽象装饰类 * @date 16:01 2020/1/6 */public class ComponentDecorate extends Component &#123; // 与抽象构件类建立关联关系 private Component component; public ComponentDecorate(Component component) &#123; this.component = component; &#125; @Override void display() &#123; this.component.display(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author Wangzy * @Description: 具体装饰类（加滚动条） * @date 16:05 2020/1/6 */public class ScrollBarDecorator extends ComponentDecorate &#123; public ScrollBarDecorator(Component component) &#123; super(component); &#125; @Override public void display() &#123; // 实现原有的显示功能 super.display(); // 实现加滚动条功能 this.setScrollBar(); &#125; private void setScrollBar() &#123; System.out.println(\"添加滚动条!\"); &#125;&#125;/** * @author Wangzy * @Description: 具体装饰类（加黑色边框） * @date 16:05 2020/1/6 */public class BlackBorderDecorator extends ComponentDecorate &#123; public BlackBorderDecorator(Component component) &#123; super(component); &#125; @Override public void display() &#123; // 实现原有的显示功能 super.display(); // 实现加黑色边框功能 this.setBlackBorder(); &#125; private void setBlackBorder() &#123; System.out.println(\"添加黑色边框!\"); &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7424685https://blog.csdn.net/lovelion/article/details/7425849https://blog.csdn.net/lovelion/article/details/7425861https://blog.csdn.net/lovelion/article/details/7425873","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://yoursite.com/tags/结构型模式/"}]},{"title":"组合模式","slug":"composite-pattern","date":"2020-01-06T06:26:00.000Z","updated":"2020-01-06T07:11:10.852Z","comments":true,"path":"2020/01/06/composite-pattern/","link":"","permalink":"http://yoursite.com/2020/01/06/composite-pattern/","excerpt":"设计模式之组合模式定义&emsp;&emsp;组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。 了解&emsp;&emsp;组合模式为处理树形结构提供了一种较为完美的解决方案，它描述了如何将容器和叶子进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器和叶子。&emsp;&emsp;对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象）并调用执行，牵一而动百，其中使用了递归调用的机制来对整个结构进行处理。由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下我们希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。组合模式为解决此类问题而诞生，它可以让叶子对象和容器对象的使用具有一致性。","text":"设计模式之组合模式定义&emsp;&emsp;组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。 了解&emsp;&emsp;组合模式为处理树形结构提供了一种较为完美的解决方案，它描述了如何将容器和叶子进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器和叶子。&emsp;&emsp;对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象）并调用执行，牵一而动百，其中使用了递归调用的机制来对整个结构进行处理。由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下我们希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。组合模式为解决此类问题而诞生，它可以让叶子对象和容器对象的使用具有一致性。 结构图&emsp;&emsp;在组合模式中引入了抽象构件类Component，它是所有容器类和叶子类的公共父类，客户端针对Component进行编程。 Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。 Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。 Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。 &emsp;&emsp;组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。 典型代码1234567// 抽象构件类abstract class Component &#123; abstract void add(Component c); //增加成员 abstract void remove(Component c); //删除成员 abstract Component getChild(int i); //获取成员 abstract void operation(); //业务方法&#125; 12345678910111213141516171819// 叶子构件class Leaf extends Component &#123; public void add(Component c) &#123; //异常处理或错误提示 &#125; public void remove(Component c) &#123; //异常处理或错误提示 &#125; public Component getChild(int i) &#123; //异常处理或错误提示 return null; &#125; public void operation() &#123; //叶子构件具体业务方法的实现 &#125; &#125; 12345678910111213141516171819202122232425// 容器构件class Composite extends Component &#123; private ArrayList&lt;Component&gt; list = new ArrayList&lt;Component&gt;(); public void add(Component c) &#123; list.add(c); &#125; public void remove(Component c) &#123; list.remove(c); &#125; public Component getChild(int i) &#123; return (Component)list.get(i); &#125; public void operation() &#123; //容器构件具体业务方法的实现 //递归调用成员构件的业务方法 for(Object obj:list) &#123; ((Component)obj).operation(); &#125; &#125; &#125; 示例 透明组合模式与安全组合模式&emsp;&emsp;由于在抽象构件类中声明了大量用于管理和访问成员构件的方法，例如add()、remove()等方法，我们不得不在新增的文件类中实现这些方法，提供对应的错误提示和异常处理。根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。 透明组合模式&emsp;&emsp;将叶子构件的add()、remove()等方法的实现代码移至抽象构件类中，由其提供统一的默认实现，若不希望出现任何错误提示，我们可以在客户端定义文件对象时不使用抽象层，而直接使用具体叶子构件本身。 栗子：1234567891011121314151617//提供默认实现的抽象构件类abstract class AbstractFile &#123; public void add(AbstractFile file) &#123; System.out.println(\"对不起，不支持该方法！\"); &#125; public void remove(AbstractFile file) &#123; System.out.println(\"对不起，不支持该方法！\"); &#125; public AbstractFile getChild(int i) &#123; System.out.println(\"对不起，不支持该方法！\"); return null; &#125; public abstract void killVirus();&#125; 12345678910class Client &#123; public static void main(String args[]) &#123; //不能透明处理叶子构件 ImageFile file1,file2; TextFile file3,file4; VideoFile file5; AbstractFile folder1,folder2,folder3,folder4; //其他代码省略 &#125;&#125; &emsp;&emsp;透明组合模式也是组合模式的标准形式，虽然上面的栗子在客户端可以有不透明的实现方法，但是由于在抽象构件中包含add()、remove()等方法，因此它还是透明组合模式。&emsp;&emsp;透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 安全组合模式&emsp;&emsp;安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法 &emsp;&emsp;在抽象构件AbstractFile中不声明任何用于访问和管理成员构件的方法。栗子：123abstract class AbstractFile &#123; public abstract void killVirus();&#125; 12345678class Client &#123; public static void main(String args[]) &#123; AbstractFile file1,file2,file3,file4,file5; Folder folder1,folder2,folder3,folder4; //不能透明处理容器构件 //其他代码省略 &#125;&#125; &emsp;&emsp;安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高，在Java AWT中使用的组合模式就是安全组合模式。 总结&emsp;&emsp;组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。在XML解析、组织结构树处理、文件系统设计等领域，组合模式都得到了广泛应用。 优点 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 缺点&emsp;&emsp;在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。 适用场景 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 在一个使用面向对象语言开发的系统中需要处理一个树形结构。 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。 code12345678910111213141516171819202122232425262728293031323334/** * @author Wangzy * @Description: 客户类 * @date 13:17 2020/1/6 */public class Client &#123; public static void main(String[] args) &#123; AbstractFile folder = new Folder(\"file\"); AbstractFile imageFolder = new Folder(\"image\"); AbstractFile imageFile = new ImageFile(\"aaa.img\"); AbstractFile imageFile1 = new ImageFile(\"bbb.jpg\"); imageFolder.add(imageFile); imageFolder.add(imageFile1); AbstractFile textFolder = new Folder(\"text\"); AbstractFile textFile = new TextFile(\"jinpingmei.doc\"); AbstractFile textFile1 = new TextFile(\"wangzhi.xsl\"); textFolder.add(textFile); textFolder.add(textFile1); AbstractFile videoFolder = new Folder(\"video\"); AbstractFile videoFile = new VideoFile(\"canglaoshi.avi\"); videoFolder.add(videoFile); folder.add(imageFolder); folder.add(textFolder); folder.add(videoFolder); folder.killVius(); &#125;&#125; 1234567891011121314151617181920/** * @author Wangzy * @Description: 抽象架构类 * @date 13:17 2020/1/6 */abstract class AbstractFile &#123; abstract void add(AbstractFile file); abstract void remove(AbstractFile file); abstract AbstractFile getChild(int i); /** * @Description: 杀毒 * @author Wangzy * @date 13:19 2020/1/6 */ abstract void killVius();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.ArrayList;import java.util.List;/** * @author Wangzy * @Description: 容器构件类 * @date 13:20 2020/1/6 */public class Folder extends AbstractFile &#123; private String name; public Folder(String name) &#123; this.name = name; &#125; private List&lt;AbstractFile&gt; fileList = new ArrayList&lt;&gt;(); @Override void add(AbstractFile file) &#123; this.fileList.add(file); &#125; @Override void remove(AbstractFile file) &#123; this.fileList.remove(file); &#125; @Override AbstractFile getChild(int i) &#123; return this.fileList.get(i); &#125; @Override void killVius() &#123; System.out.println(\"开始对文件夹：\" + this.name + \"进行杀毒!\"); // 递归调用处理文件夹层级结构 for (AbstractFile abstractFile : this.fileList) &#123; abstractFile.killVius(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * @author Wangzy * @Description: 叶子构件类 * @date 13:30 2020/1/6 */public class ImageFile extends AbstractFile &#123; private String name; public ImageFile(String name) &#123; this.name = name; &#125; @Override void add(AbstractFile file) &#123; System.out.println(\"不支持的操作!\"); &#125; @Override void remove(AbstractFile file) &#123; System.out.println(\"不支持的操作!\"); &#125; @Override AbstractFile getChild(int i) &#123; System.out.println(\"不支持的操作!\"); return null; &#125; @Override void killVius() &#123; System.out.println(\"开始对文件：\" + this.name + \"进行杀毒!\"); &#125;&#125;/** * @author Wangzy * @Description: 叶子构件类 * @date 13:30 2020/1/6 */public class TextFile extends AbstractFile &#123; private String name; public TextFile(String name) &#123; this.name = name; &#125; @Override void add(AbstractFile file) &#123; System.out.println(\"不支持的操作!\"); &#125; @Override void remove(AbstractFile file) &#123; System.out.println(\"不支持的操作!\"); &#125; @Override AbstractFile getChild(int i) &#123; System.out.println(\"不支持的操作!\"); return null; &#125; @Override void killVius() &#123; System.out.println(\"开始对文件：\" + this.name + \"进行杀毒!\"); &#125;&#125;/** * @author Wangzy * @Description: 叶子构件类 * @date 13:30 2020/1/6 */public class VideoFile extends AbstractFile &#123; private String name; public VideoFile(String name) &#123; this.name = name; &#125; @Override void add(AbstractFile file) &#123; System.out.println(\"不支持的操作!\"); &#125; @Override void remove(AbstractFile file) &#123; System.out.println(\"不支持的操作!\"); &#125; @Override AbstractFile getChild(int i) &#123; System.out.println(\"不支持的操作!\"); return null; &#125; @Override void killVius() &#123; System.out.println(\"开始对文件：\" + this.name + \"进行杀毒!\"); &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7956898https://blog.csdn.net/lovelion/article/details/7956908https://blog.csdn.net/lovelion/article/details/7956931https://blog.csdn.net/lovelion/article/details/7956937https://blog.csdn.net/lovelion/article/details/7956962","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://yoursite.com/tags/结构型模式/"}]},{"title":"外观模式","slug":"facade-pattern","date":"2019-12-31T06:40:02.000Z","updated":"2019-12-31T08:05:09.816Z","comments":true,"path":"2019/12/31/facade-pattern/","link":"","permalink":"http://yoursite.com/2019/12/31/facade-pattern/","excerpt":"设计模式之外观模式定义&emsp;&emsp;外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 了解&emsp;&emsp;外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。&emsp;&emsp;一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互。外观模式通过引入一个新的外观类(Facade)来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。在外观模式中，那些需要交互的业务类被称为子系统(Subsystem)。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大;而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度. 栗子：","text":"设计模式之外观模式定义&emsp;&emsp;外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 了解&emsp;&emsp;外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。&emsp;&emsp;一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互。外观模式通过引入一个新的外观类(Facade)来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。在外观模式中，那些需要交互的业务类被称为子系统(Subsystem)。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大;而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度. 栗子： 结构图Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。 典型代码123456789101112131415161718192021222324// 子系统class SubSystemA&#123; public void MethodA() &#123; //业务实现代码 &#125;&#125; class SubSystemB&#123; public void MethodB() &#123; //业务实现代码 &#125;&#125; class SubSystemC&#123; public void MethodC() &#123; //业务实现代码 &#125;&#125; 1234567891011121314// 外观类class Facade&#123; private SubSystemA obj1 = new SubSystemA(); private SubSystemB obj2 = new SubSystemB(); private SubSystemC obj3 = new SubSystemC(); public void Method() &#123; obj1.MethodA(); obj2.MethodB(); obj3.MethodC(); &#125;&#125; // 客户类12345678class Program&#123; static void Main(string[] args) &#123; Facade facade = new Facade(); facade.Method(); &#125;&#125; 示例 抽象外观类&emsp;&emsp;在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类来对系统进行改进，在一定程度上可以解决该问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。&emsp;&emsp;如果不增加新的外观类，只能通过修改原有外观类Facade的源代码来实现加密类的更换，将原有的对CipherMachine类型对象的引用改为对NewCipherMachine类型对象的引用，这违背了开闭原则，因此需要通过增加新的外观类来实现对子系统对象引用的改变。如果增加一个新的外观类NewFacade来与FileReader类、FileWriter类以及新增加的NewCipherMachine类进行交互，虽然原有系统类库无须做任何修改，但是因为客户端代码中原来针对Facade类进行编程，现在需要改为NewFacade类，因此需要修改客户端源代码。因此引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类。栗子：&emsp;&emsp;原有外观类Facade也需作为抽象外观类AbstractFacade类的子类，更换具体外观类时只需修改配置文件，无须修改源代码，符合开闭原则。具体见下面撸的代码!!! 总结&emsp;&emsp;外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。在几乎所有的软件中都能够找到外观模式的应用，如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度。所有涉及到与多个业务对象交互的场景都可以考虑使用外观模式进行重构。 优点 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 缺点 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 适用场景当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。客户端程序与多个子系统之间存在很大的依赖性（引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性）。层次化结构（可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度）。 code12345678910111213141516/** * @author Wangzy * @Description: 客户类 * @date 15:26 2019/12/31 */public class Client &#123; public static void main(String[] args) &#123; // 直接通过(抽象)外观类调用各个子类业务系统// AbstractFacade facade = new Facade(); AbstractFacade facade = new NewFacade(); facade.method(\"a.txt\", \"b.txt\"); System.out.println(\"all is well！\"); &#125;&#125; 123456789/** * @author Wangzy * @Description: 抽象外观类 * @date 15:49 2019/12/31 */public interface AbstractFacade &#123; void method(String srcPath, String descPath);&#125; 12345678910111213141516171819202122232425262728/** * @author Wangzy * @Description: 外观类 * @date 15:17 2019/12/31 */public class Facade implements AbstractFacade &#123; private FileReader fileReader; private CipherMachine cipherMachine; private FileWriter fileWriter; public Facade() &#123; this.fileReader = new FileReader(); this.cipherMachine = new CipherMachine(); this.fileWriter = new FileWriter(); &#125; @Override public void method(String srcPath, String descPath) &#123; System.out.println(\"通过外观类调用各个具体子类业务系统&gt;&gt;&gt;\"); String read = this.fileReader.read(srcPath); String encrypt = this.cipherMachine.encrypt(read); this.fileWriter.writeFile(descPath, encrypt); &#125;&#125; 12345678910111213141516171819202122232425262728/** * @author Wangzy * @Description: 外观类 * @date 15:17 2019/12/31 */public class NewFacade implements AbstractFacade &#123; private FileReader fileReader; private NewCipherMachine cipherMachine; private FileWriter fileWriter; public NewFacade() &#123; this.fileReader = new FileReader(); this.cipherMachine = new NewCipherMachine(); this.fileWriter = new FileWriter(); &#125; @Override public void method(String srcPath, String descPath) &#123; System.out.println(\"通过外观类调用各个具体子类业务系统&gt;&gt;&gt;\"); String read = this.fileReader.read(srcPath); String encrypt = this.cipherMachine.encrypt(read); this.fileWriter.writeFile(descPath, encrypt); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * @author Wangzy * @Description: 加密器（业务系统之一） * @date 14:59 2019/12/31 */public class CipherMachine &#123; public String encrypt(String plainText) &#123; System.out.println(\"数据加密，将明文转换为密文：\"); String es = \"\"; char[] chars = plainText.toCharArray(); for (char aChar : chars) &#123; String c = String.valueOf(aChar % 7); es += c; &#125; System.out.println(es); return es; &#125;&#125;/** * @author Wangzy * @Description: 加密器（业务系统之一） * @date 14:59 2019/12/31 */public class NewCipherMachine &#123; /** * @Description: 基于位运算加密 * @author Wangzy * @date 15:41 2019/12/31 */ public String encrypt(String plainText) &#123; System.out.println(\"数据加密，将明文转换为密文：\"); String es = \"\"; int key = 10;//设置密钥，移位数为10 char[] chars = plainText.toCharArray(); for (char ch : chars) &#123; int temp = Integer.valueOf(ch); //小写字母移位 if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; temp += key % 26; if (temp &gt; 122) &#123; temp -= 26; &#125; if (temp &lt; 97) &#123; temp += 26; &#125; &#125; //大写字母移位 if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; temp += key % 26; if (temp &gt; 90) &#123; temp -= 26; &#125; if (temp &lt; 65) &#123; temp += 26; &#125; &#125; es += String.valueOf((char)temp); &#125; System.out.println(es); return es; &#125;&#125;import java.io.*;/** * @author Wangzy * @Description: 读取文件（业务功能之一） * @date 14:52 2019/12/31 */public class FileReader &#123; public String read(String filepath) &#123; try &#123; File file = new File(filepath); FileInputStream fis = new FileInputStream(file); long filelength = file.length(); byte[] bb = new byte[(int) filelength]; fis.read(bb); fis.close(); System.out.println(\"读取文件成功！加密前明文: \" + new String(bb)); return new String(bb); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125;&#125;import java.io.*;/** * @author Wangzy * @Description: 保存加密后文档（业务系统之一） * @date 15:03 2019/12/31 */public class FileWriter &#123; public void writeFile(String path, String txt) &#123; File file = new File(path); try &#123; if (!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream output = new FileOutputStream(file); byte[] bytes = txt.getBytes(); output.write(bytes); output.close(); System.out.println(\"成功将加密数据写入目标文档!\"); &#125; catch (IOException e) &#123; System.out.println(\"将加密数据写入目标文档失败!\"); &#125; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/8258121https://blog.csdn.net/lovelion/article/details/8259705https://blog.csdn.net/lovelion/article/details/8259789","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://yoursite.com/tags/结构型模式/"}]},{"title":"桥接模式","slug":"bridge-pattern","date":"2019-12-31T05:21:02.000Z","updated":"2019-12-31T06:01:29.110Z","comments":true,"path":"2019/12/31/bridge-pattern/","link":"","permalink":"http://yoursite.com/2019/12/31/bridge-pattern/","excerpt":"设计模式之桥接模式定义&emsp;&emsp;桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 了解&emsp;&emsp;桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。&emsp;&emsp;用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。&emsp;&emsp;桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。&emsp;&emsp;在使用桥接模式时，我们首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。通常情况下，我们将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽&emsp;&emsp;象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。例如：对于毛笔而言，由于型号是其固有的维度，因此可以设计一个抽象的毛笔类，在该类中声明并部分实现毛笔的业务方法，而将各种型号的毛笔作为其子类；颜色是毛笔的另一个维度，由于它与毛笔之间存在一种“设置”的关系，因此我们可以提供一个抽象的颜色接口，而将具体的颜色作为实现该接口的子类。&emsp;&emsp;上面栗子中如果需要增加一种新型号的毛笔，只需扩展左侧的“抽象部分”，增加一个新的扩充抽象类；如果需要增加一种新的颜色，只需扩展右侧的“实现部分”，增加一个新的具体实现类。扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。","text":"设计模式之桥接模式定义&emsp;&emsp;桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。 了解&emsp;&emsp;桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。&emsp;&emsp;用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。&emsp;&emsp;桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。&emsp;&emsp;在使用桥接模式时，我们首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。通常情况下，我们将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽&emsp;&emsp;象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。例如：对于毛笔而言，由于型号是其固有的维度，因此可以设计一个抽象的毛笔类，在该类中声明并部分实现毛笔的业务方法，而将各种型号的毛笔作为其子类；颜色是毛笔的另一个维度，由于它与毛笔之间存在一种“设置”的关系，因此我们可以提供一个抽象的颜色接口，而将具体的颜色作为实现该接口的子类。&emsp;&emsp;上面栗子中如果需要增加一种新型号的毛笔，只需扩展左侧的“抽象部分”，增加一个新的扩充抽象类；如果需要增加一种新的颜色，只需扩展右侧的“实现部分”，增加一个新的具体实现类。扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。 结构图 Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。 RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。 Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。 ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。 典型代码1234// 实现部分interface Implementor &#123; public void operationImpl();&#125; 12345678910// 抽象部分abstract class Abstraction &#123; protected Implementor impl; //定义实现类接口对象 public void setImpl(Implementor impl) &#123; this.impl=impl; &#125; public abstract void operation(); //声明抽象业务方法&#125; 12345678// 扩充抽象类class RefinedAbstraction extends Abstraction &#123; public void operation() &#123; //业务代码 impl.operationImpl(); //调用实现类的方法 //业务代码 &#125;&#125; &emsp;&emsp;对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响 示例&emsp;&emsp;当增加新的图像文件格式或者操作系统时，原有系统无须做任何修改，只需增加一个对应的扩充抽象类或具体实现类即可，系统具有较好的可扩展性，完全符合“开闭原则”。 与适配器模式的联合使用&emsp;&emsp;桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。栗子： 总结&emsp;&emsp;桥接模式是设计Java虚拟机和实现JDBC等驱动程序的核心模式之一，应用较为广泛。在软件开发中如果一个类或一个系统有多个变化维度时，都可以尝试使用桥接模式对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。 优点 分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。 在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。 缺点 桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。 适用场景 如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。 “抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。 对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 code123456789101112131415/** * @author Wangzy * @Description: 客户类 * @date 11:21 2019/12/31 */public class Client &#123; public static void main(String[] args) &#123; // windows系统显示jpg格式的像素图片 动态耦合 ImageImp imageImp = new WindowsImp(); Image image = new JPGImage(); image.setImageImp(imageImp); image.parseFile(\"aaa.jpg\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * @author Wangzy * @Description: 像素对象 * @date 11:21 2019/12/31 */public class Matrix &#123; private Integer hight; private Integer width; public Integer getHight() &#123; return hight; &#125; public void setHight(Integer hight) &#123; this.hight = hight; &#125; public Integer getWidth() &#123; return width; &#125; public void setWidth(Integer width) &#123; this.width = width; &#125; @Override public String toString() &#123; return \"Matrix&#123;\" + \"hight=\" + hight + \", width=\" + width + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324/** * @author Wangzy * @Description: 抽象类 * @date 11:27 2019/12/31 */abstract class Image &#123; /** * @Description: 和具体实现类之间建立关联关系 * @author Wangzy * @date 11:28 2019/12/31 */ protected ImageImp imageImp; public void setImageImp(ImageImp imageImp) &#123; this.imageImp = imageImp; &#125; /** * @Description: 设置文件格式，如jpg，png，gif，bmp etc * @author Wangzy * @date 11:30 2019/12/31 */ abstract void parseFile(String filename);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * @author Wangzy * @Description: gif（扩充抽象类） * @date 11:34 2019/12/31 */public class GIFImage extends Image &#123; @Override void parseFile(String filename) &#123; // 绘制像素 Matrix matrix = new Matrix(); matrix.setHight(2); matrix.setWidth(2); System.out.println(\"绘制gif图片：\" + filename); // 扩充抽象类子类可以调用具体实现类的显示方法 imageImp.doPaint(matrix); &#125;&#125;/** * @author Wangzy * @Description: jpg（扩充抽象类） * @date 11:34 2019/12/31 */public class JPGImage extends Image &#123; @Override void parseFile(String filename) &#123; // 绘制像素 Matrix matrix = new Matrix(); matrix.setHight(1); matrix.setWidth(1); System.out.println(\"绘制jpg图片：\" + filename); // 扩充抽象类子类可以调用具体实现类的显示方法 imageImp.doPaint(matrix); &#125;&#125;/** * @author Wangzy * @Description: png（扩充抽象类） * @date 11:34 2019/12/31 */public class PNGImage extends Image &#123; @Override void parseFile(String filename) &#123; // 绘制像素 Matrix matrix = new Matrix(); matrix.setHight(4); matrix.setWidth(4); System.out.println(\"绘制png图片：\" + filename); // 扩充抽象类子类可以调用具体实现类的显示方法 imageImp.doPaint(matrix); &#125;&#125;/** * @author Wangzy * @Description: bmp（扩充抽象类） * @date 11:34 2019/12/31 */public class BMPImage extends Image &#123; @Override void parseFile(String filename) &#123; // 绘制像素 Matrix matrix = new Matrix(); matrix.setHight(3); matrix.setWidth(3); System.out.println(\"绘制bmp图片：\" + filename); // 扩充抽象类子类可以调用具体实现类的显示方法 imageImp.doPaint(matrix); &#125;&#125; 12345678910/** * @author Wangzy * @Description: 具体实现类（将像素显示到不同的操作系统上） * @date 11:23 2019/12/31 */public interface ImageImp &#123; void doPaint(Matrix matrix);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author Wangzy * @Description: linux系统 * @date 11:24 2019/12/31 */public class LinuxImp implements ImageImp &#123; @Override public void doPaint(Matrix matrix) &#123; System.out.println(\"linux系统显示像素：\" + matrix.toString()); &#125;&#125;/** * @author Wangzy * @Description: unix系统 * @date 11:24 2019/12/31 */public class UnixImp implements ImageImp &#123; @Override public void doPaint(Matrix matrix) &#123; System.out.println(\"unix系统显示像素：\" + matrix.toString()); &#125;&#125;/** * @author Wangzy * @Description: windows系统 * @date 11:24 2019/12/31 */public class WindowsImp implements ImageImp &#123; @Override public void doPaint(Matrix matrix) &#123; System.out.println(\"windows系统显示像素：\" + matrix.toString()); &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7464183https://blog.csdn.net/lovelion/article/details/7464195https://blog.csdn.net/lovelion/article/details/7464204https://blog.csdn.net/lovelion/article/details/7464208","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://yoursite.com/tags/结构型模式/"}]},{"title":"适配器模式","slug":"adapter-pattern","date":"2019-12-30T08:55:01.000Z","updated":"2019-12-30T11:42:29.008Z","comments":true,"path":"2019/12/30/adapter-pattern/","link":"","permalink":"http://yoursite.com/2019/12/30/adapter-pattern/","excerpt":"设计模式之适配器模式定义&emsp;&emsp; 适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 了解&emsp;&emsp;与电源适配器相似，在适配器模式中引入了一个被称为适配器(Adapter)的包装类，而它所包装的对象称为适配者(Adaptee)，即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。&emsp;&emsp;根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高。","text":"设计模式之适配器模式定义&emsp;&emsp; 适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 了解&emsp;&emsp;与电源适配器相似，在适配器模式中引入了一个被称为适配器(Adapter)的包装类，而它所包装的对象称为适配者(Adaptee)，即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。&emsp;&emsp;根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高。 （对象适配器）结构图 Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 1234567891011class Adapter extends Target &#123; private Adaptee adaptee; //维持一个对适配者对象的引用 public Adapter(Adaptee adaptee) &#123; this.adaptee=adaptee; &#125; public void request() &#123; adaptee.specificRequest(); //转发调用 &#125;&#125; 示例 类适配器&emsp;&emsp;类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系。适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificRequest()方法，从而实现适配。 12345class Adapter extends Adaptee implements Target &#123; public void request() &#123; specificRequest(); &#125;&#125; &emsp;&emsp;在Java中，大部分情况下我们使用的是对象适配器，因为Java不支持多继承，如果目标抽象类Target不是接口或者适配者Adaptee被final关键字修饰，都无法使用类适配器。 双向适配器&emsp;&emsp;所谓双向适配器就是在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法。实际开发中，我们很少使用双向适配器。 123456789101112131415161718192021class Adapter implements Target,Adaptee &#123; //同时维持对抽象目标类和适配者的引用 private Target target; private Adaptee adaptee; public Adapter(Target target) &#123; this.target = target; &#125; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void request() &#123; adaptee.specificRequest(); &#125; public void specificRequest() &#123; target.request(); &#125;&#125; 缺省适配器&emsp;&emsp;缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。 ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。 AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。 ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法也不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适配器类中定义的方法。 总结&emsp;&emsp;适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在Spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。 优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 针对类适配器模式而言，由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 针对对象适配器而言，一个对象适配器可以把多个不同的适配者适配到同一个目标；可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配 缺点 针对类适配器而言，Java不支持多重类继承，一次最多只能适配一个适配者类，不能同时适配多个适配者；适配者类不能为最终类；类适配器模式中的目标抽象类只能为接口，不能为类。 针对对象适配器而言，与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 适用场景 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类（包括一些可能在将来引进的类）一起工作。 code12345678910111213141516171819202122232425262728293031323334/** * @author Wangzy * @Description: 客户类 * @date 11:15 2019/12/30 */public class Client &#123; public static void main(String[] args) &#123; // 针对抽象目标接口编程 ScoreOperation operation = new Adapter(); int scores[] = &#123;84, 76, 50, 69, 90, 91, 88, 96&#125;; int result[]; int score; System.out.println(\"成绩排序结果：\"); result = operation.sort(scores); // 遍历输出成绩 for (int i : scores) &#123; System.out.print(i + \",\"); &#125; System.out.println(); System.out.println(\"查找成绩92：\"); score = operation.query(result, 92); if (score != -1) &#123; System.out.println(\"找到成绩92。\"); &#125; else &#123; System.out.println(\"没有找到成绩92。\"); &#125; &#125;&#125; 1234567891011/** * @author Wangzy * @Description: 算法接口（客户端直接调用，类似于适用电压20v的笔记本电脑） * @date 11:18 2019/12/30 */public interface ScoreOperation &#123; int[] sort(int[] arrays); int query(int[] arrays, int i);&#125; 12345678910111213141516171819202122232425/** * @author Wangzy * @Description: 适配器（类似于笔记本电脑变压器，也称电源） * @date 11:24 2019/12/30 */public class Adapter implements ScoreOperation &#123; private QuickSort quickSort; private QuickQuery quickQuery; public Adapter() &#123; this.quickSort = new QuickSort(); this.quickQuery = new QuickQuery(); &#125; @Override public int[] sort(int[] arrays) &#123; return quickSort.quickSort(arrays); &#125; @Override public int query(int[] arrays, int i) &#123; return quickQuery.binarySearch(arrays, i); &#125;&#125; 1234567891011121314151617181920212223242526/** * @author Wangzy * @Description: 快速查找(适配者之一，类似于220v家用电源) * @date 11:23 2019/12/30 */public class QuickQuery &#123; public int binarySearch(int array[], int key) &#123; int low = 0; int high = array.length - 1; while (low &lt;= high) &#123; int mid = (low + high) / 2; int midVal = array[mid]; if (midVal &lt; key) &#123; low = mid + 1; &#125; else if (midVal &gt; key) &#123; high = mid - 1; &#125; else &#123; // 找到元素返回1 return 1; &#125; &#125; // 未找到元素返回-1 return -1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author Wangzy * @Description: 快速排序（适配者之一，类似于220v家用电源） * @date 11:21 2019/12/30 */public class QuickSort &#123; public int[] quickSort(int array[]) &#123; sort(array, 0, array.length - 1); return array; &#125; public void sort(int array[], int p, int r) &#123; int q = 0; if (p &lt; r) &#123; q = partition(array, p, r); sort(array, p, q - 1); sort(array, q + 1, r); &#125; &#125; public int partition(int[] a, int p, int r) &#123; int x = a[r]; int j = p - 1; for (int i = p; i &lt;= r - 1; i++) &#123; if (a[i] &lt;= x) &#123; j++; swap(a, j, i); &#125; &#125; swap(a, j + 1, r); return j + 1; &#125; public void swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/8624325https://blog.csdn.net/lovelion/article/details/8624412https://blog.csdn.net/lovelion/article/details/8624428https://blog.csdn.net/lovelion/article/details/8624633","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"结构型模式","slug":"结构型模式","permalink":"http://yoursite.com/tags/结构型模式/"}]},{"title":"建造者模式","slug":"builder-pattern","date":"2019-12-27T08:55:02.000Z","updated":"2019-12-30T11:36:28.541Z","comments":true,"path":"2019/12/27/builder-pattern/","link":"","permalink":"http://yoursite.com/2019/12/27/builder-pattern/","excerpt":"设计模式之建造者模式定义&emsp;&emsp; 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 了解&emsp;&emsp;建造者模式又称为生成器模式，它是一种较为复杂、使用频率也相对较低的创建型模式。建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。&emsp;&emsp;建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。","text":"设计模式之建造者模式定义&emsp;&emsp; 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 了解&emsp;&emsp;建造者模式又称为生成器模式，它是一种较为复杂、使用频率也相对较低的创建型模式。建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。&emsp;&emsp;建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。 结构图&emsp;&emsp;建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。 Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。 Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。 Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 示例 &emsp;&emsp;在建造者模式中，客户端只需实例化指挥者类，指挥者类针对抽象建造者编程，客户端根据需要传入具体的建造者类型，指挥者将指导具体建造者一步一步构造一个完整的产品（逐步调用具体建造者的buildX()方法），相同的构造过程可以创建完全不同的产品。在游戏角色实例中，如果需要更换角色，只需要修改配置文件，更换具体角色建造者类即可；如果需要增加新角色，可以增加一个新的具体角色建造者类作为抽象角色建造者的子类，再修改配置文件即可，原有代码无须修改，完全符合“开闭原则”。 Director(指挥者)123456789101112131415161718192021// 方式一：abstract class ActorBuilder&#123; protected static Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public static Actor construct(ActorBuilder ab) &#123; ab.buildType(); ab.buildSex(); ab.buildFace(); ab.buildCostume(); ab.buildHairstyle(); return actor; &#125;&#125; 123456789101112131415161718192021// 方式二（更简单）abstract class ActorBuilder&#123; protected Actor actor = new Actor(); public abstract void buildType(); public abstract void buildSex(); public abstract void buildFace(); public abstract void buildCostume(); public abstract void buildHairstyle(); public Actor construct() &#123; this.buildType(); this.buildSex(); this.buildFace(); this.buildCostume(); this.buildHairstyle(); return actor; &#125;&#125; &emsp;&emsp;以上两种对Director类的省略方式都不影响系统的灵活性和可扩展性，同时还简化了系统结构，但加重了抽象建造者类的职责，如果construct()方法较为复杂，待构建产品的组成部分较多，建议还是将construct()方法单独封装在Director中，这样做更符合“单一职责原则”。 钩子方法的引入&emsp;&emsp;钩子方法的返回类型通常为boolean类型，方法名一般为isXXX()，钩子方法定义在抽象建造者类中。&emsp;&emsp;通过引入钩子方法，我们可以在Director中对复杂产品的构建进行精细的控制，不仅指定buildPartX()方法的执行顺序，还可以控制是否需要执行某个buildPartX()方法。具体操作见下面具体代码！！！ 总结&emsp;&emsp;建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。 优点 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则” 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。 适用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 code1234567891011121314/** * @author Wangzy * @Description: 客户端 * @date 15:20 2019/12/27 */public class Client &#123; public static void main(String[] args) &#123; // 客户端直接操纵指挥者 Director director = new Director(); Role role = director.construct(new HeroBuilder()); System.out.println(\"创建角色成功! role: \" + role.toString()); &#125;&#125; 12345678910111213141516171819202122232425/** * @author Wangzy * @Description: 指挥者类 * @date 15:36 2019/12/27 */public class Director &#123; /** * @Description: 核心：指挥创建对象的步骤及顺序等 * @author Wangzy * @date 15:38 2019/12/27 */ public Role construct(Builder builder) &#123; builder.buildCostume(); builder.buildFace(); // 判断钩子方法结果确定有没有头发再做发型 if (!builder.isHeadLight()) &#123; builder.buildHairstyle(); &#125; builder.buildRole(); builder.buildSex(); builder.buildType(); return builder.buildRole(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @author Wangzy * @Description: 复杂角色 * @date 15:23 2019/12/27 */public class Role &#123; private String type; private String sex; private String face; private String costume; private String hairstyle; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getFace() &#123; return face; &#125; public void setFace(String face) &#123; this.face = face; &#125; public String getCostume() &#123; return costume; &#125; public void setCostume(String costume) &#123; this.costume = costume; &#125; public String getHairstyle() &#123; return hairstyle; &#125; public void setHairstyle(String hairstyle) &#123; this.hairstyle = hairstyle; &#125; @Override public String toString() &#123; return \"Role&#123;\" + \"type='\" + type + '\\'' + \", sex='\" + sex + '\\'' + \", face='\" + face + '\\'' + \", costume='\" + costume + '\\'' + \", hairstyle='\" + hairstyle + '\\'' + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * @author Wangzy * @Description: 抽象建造者 * @date 15:21 2019/12/27 */public abstract class Builder &#123; protected Role role = new Role(); abstract void buildType(); abstract void buildSex(); abstract void buildFace(); abstract void buildCostume(); abstract void buildHairstyle(); /** * @Description: 创建钩子方法来\"定制产品\" * @author Wangzy * @date 17:43 2019/12/27 */ boolean isHeadLight() &#123; return false; &#125; Role buildRole() &#123; return role; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * @author Wangzy * @Description: 具体建造者（天使角色） * @date 15:21 2019/12/27 */public class AngelBuilder extends Builder &#123; @Override void buildType() &#123; this.role.setType(\"angel type!\"); System.out.println(\"build angel type!\"); &#125; @Override void buildSex() &#123; this.role.setSex(\"angel sex!\"); System.out.println(\"build angel sex!\"); &#125; @Override void buildFace() &#123; this.role.setFace(\"angel face!\"); System.out.println(\"build angel face!\"); &#125; @Override void buildCostume() &#123; this.role.setCostume(\"angel costume!\"); System.out.println(\"build angel costume!\"); &#125; @Override void buildHairstyle() &#123; this.role.setHairstyle(\"angel hairstyle!\"); System.out.println(\"build angel hairstyle!\"); &#125;&#125;/** * @author Wangzy * @Description: 具体建造者（恶魔角色） * @date 15:21 2019/12/27 */public class DevilBuilder extends Builder &#123; @Override void buildType() &#123; this.role.setType(\"devil type!\"); System.out.println(\"build devil type!\"); &#125; @Override void buildSex() &#123; this.role.setSex(\"devil sex!\"); System.out.println(\"build devil sex!\"); &#125; @Override void buildFace() &#123; this.role.setFace(\"devil face!\"); System.out.println(\"build devil face!\"); &#125; @Override void buildCostume() &#123; this.role.setCostume(\"devil costume!\"); System.out.println(\"build devil costume!\"); &#125; @Override void buildHairstyle() &#123; this.role.setHairstyle(\"devil hairstyle!\"); System.out.println(\"build devil hairstyle!\"); &#125;&#125;/** * @author Wangzy * @Description: 具体建造者（英雄角色） * @date 15:21 2019/12/27 */public class HeroBuilder extends Builder &#123; @Override void buildType() &#123; this.role.setType(\"hero type!\"); System.out.println(\"build hero type!\"); &#125; @Override void buildSex() &#123; this.role.setSex(\"hero sex!\"); System.out.println(\"build hero sex!\"); &#125; @Override void buildFace() &#123; this.role.setFace(\"hero face!\"); System.out.println(\"build hero face!\"); &#125; @Override void buildCostume() &#123; this.role.setCostume(\"hero costume!\"); System.out.println(\"build hero costume!\"); &#125; @Override void buildHairstyle() &#123; this.role.setHairstyle(\"hero hairstyle!\"); System.out.println(\"build hero hairstyle!\"); &#125; /** * @Description: 复写抽象建造者类中的钩子方法，英雄必须是光头!!! * @author Wangzy * @date 17:46 2019/12/27 */ @Override boolean isHeadLight() &#123; return true; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7426015https://blog.csdn.net/lovelion/article/details/7426323https://blog.csdn.net/lovelion/article/details/7426855","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://yoursite.com/tags/创建型模式/"}]},{"title":"原型模式","slug":"prototype-pattern","date":"2019-12-26T10:30:01.000Z","updated":"2019-12-30T08:49:07.932Z","comments":true,"path":"2019/12/26/prototype-pattern/","link":"","permalink":"http://yoursite.com/2019/12/26/prototype-pattern/","excerpt":"设计模式之原型模式定义&emsp;&emsp;原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。 了解&emsp;&emsp;在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。","text":"设计模式之原型模式定义&emsp;&emsp;原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。 了解&emsp;&emsp;在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。 结构图 Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。 ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。 核心（克隆方法）通用实现方法&emsp;&emsp;通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证它们的成员属性相同。1234567891011121314151617class ConcretePrototype implements Prototype &#123; private String attr; //成员属性 public void setAttr(String attr) &#123; this.attr = attr; &#125; public String getAttr() &#123; return this.attr; &#125; public Prototype clone() //克隆方法 &#123; Prototype prototype = new ConcretePrototype(); //创建新对象 prototype.setAttr(this.attr); return prototype; &#125;&#125; 123Prototype obj1 = new ConcretePrototype();obj1.setAttr(\"Sunny\");Prototype obj2 = obj1.clone(); Java语言提供的clone()方法（常用）&emsp;&emsp;能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常 123456789101112131415class ConcretePrototype implements Cloneable&#123;……public Prototype clone()&#123; Object object = null; try &#123; object = super.clone(); &#125; catch (CloneNotSupportedException exception) &#123; System.err.println(\"Not support cloneable\"); &#125; return (Prototype )object;&#125;……&#125; 12Prototype obj1 = new ConcretePrototype();Prototype obj2 = obj1.clone(); 示例 浅克隆和深克隆浅克隆&emsp;&emsp;在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。example： 深克隆&emsp;&emsp;在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。&emsp;&emsp;在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。example： 原型管理器&emsp;&emsp;原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便扩展。example： 总结&emsp;&emsp;原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的复制(Ctrl + C)和粘贴(Ctrl + V)操作就是原型模式的典型应用。 优点 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。 缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 适用场景 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 code浅克隆和深克隆123456789101112131415161718192021222324252627282930313233343536373839/** * @author Wangzy * @Description: 启动类 * @date 14:02 2019/12/26 */public class Boot &#123; public static void main(String[] args) &#123; // 先创建一个对象 WeeklyLog weeklyLog = new WeeklyLog(); weeklyLog.setContent(\"做了!\"); weeklyLog.setDate(\"第一周\"); weeklyLog.setName(\"pdd\"); // 设置附件 Attachment attachment = new Attachment(); attachment.setAttachmentName(\"附件a\"); weeklyLog.setAttachment(attachment); System.out.println(weeklyLog.getName() + weeklyLog.getDate() + weeklyLog.getContent()); // 克隆对象 WeeklyLog weeklyLog1 = null;// WeeklyLog weeklyLog1 = weeklyLog.clone(); // 深克隆 try &#123; weeklyLog1 = weeklyLog.deepClone(); &#125; catch (Exception e) &#123; System.out.println(\"深克隆异常!\"); &#125; weeklyLog1.setDate(\"第二周\"); System.out.println(weeklyLog1.getName() + weeklyLog1.getDate() + weeklyLog1.getContent()); // 比较 System.out.println(weeklyLog == weeklyLog1); // false System.out.println(weeklyLog.getDate() == weeklyLog1.getDate()); // false System.out.println(weeklyLog.getName() == weeklyLog1.getName()); // true System.out.println(weeklyLog.getContent() == weeklyLog1.getContent()); // true System.out.println(weeklyLog.getAttachment() == weeklyLog1.getAttachment()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.*;/** * @author Wangzy * @Description: 工作周报 * @date 14:02 2019/12/26 */public class WeeklyLog implements Cloneable, Serializable &#123; private String name; private String date; private String content; // 附件 private Attachment attachment; public Attachment getAttachment() &#123; return attachment; &#125; public void setAttachment(Attachment attachment) &#123; this.attachment = attachment; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; /** * @Description: 复写clone方法克隆对象 * @author Wangzy * @date 14:03 2019/12/26 */ @Override public WeeklyLog clone() &#123; Object object = null; try &#123; object = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; System.out.println(\"不支持的克隆类!\"); &#125; return (WeeklyLog) object; &#125; /** * @Description: 深克隆 （包括引用类型的成员变量都会克隆） * @author Wangzy * @date 15:27 2019/12/26 */ public WeeklyLog deepClone() throws IOException, ClassNotFoundException &#123; // 将对象写入流中 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 将对象从流中取出 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (WeeklyLog) ois.readObject(); &#125;&#125; 12345678910111213141516171819202122232425262728import java.io.Serializable;/** * @author Wangzy * @Description: 周报附件（代表引用类型，用来区分浅克隆还是深克隆） * @date 15:11 2019/12/26 */public class Attachment implements Serializable &#123; private String attachmentName; public String getAttachmentName() &#123; return attachmentName; &#125; public void setAttachmentName(String attachmentName) &#123; this.attachmentName = attachmentName; &#125; /** * @Description: 模拟附件下载功能 * @author Wangzy * @date 15:13 */ public void download() &#123; System.out.println(\"下载\" + this.attachmentName + \"附件成功\"); &#125;&#125; 包含原型管理器1234567891011121314151617181920212223/** * @author Wangzy * @Description: 启动类 * @date 14:02 2019/12/26 */public class PMBoot &#123; public static void main(String[] args) &#123; // 获取单例创建的原型管理器 PrototypeManager prototypeManager = PrototypeManager.getInstance(); // 获取克隆对象 OfficalDocument farclone1 = prototypeManager.getOfficalDocument(\"far\"); OfficalDocument farclone2 = prototypeManager.getOfficalDocument(\"far\"); farclone1.display(); farclone2.display(); System.out.println(farclone1 == farclone2); OfficalDocument srsclone1 = prototypeManager.getOfficalDocument(\"srs\"); OfficalDocument srsclone2 = prototypeManager.getOfficalDocument(\"srs\"); srsclone1.display(); srsclone2.display(); System.out.println(srsclone1 == srsclone2); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Hashtable;/** * @author Wangzy * @Description: 原型管理器(以公文管理器为例) * @date 16:17 2019/12/26 */public class PrototypeManager &#123; // 用来存放原型 Hashtable&lt;String, Object&gt; hashtable = new Hashtable&lt;&gt;(); // 饿汉式单例模式生成原型管理器 private static final PrototypeManager prototypeManager = new PrototypeManager(); private PrototypeManager() &#123; hashtable.put(\"far\", new FAR()); hashtable.put(\"srs\", new SRS()); &#125; public static PrototypeManager getInstance() &#123; return prototypeManager; &#125; /** * @Description: 添加原型, 可通过此方法进行扩展，只需要新建一个具体原型类并且调用该方法存入key，value值即可，符合“开闭原则” * @author Wangzy * @date 16:20 2019/12/26 */ public void addOfficialDocument(String key, OfficalDocument officalDocument) &#123; hashtable.put(key, officalDocument); &#125; /** * @Description: 获取克隆对象 * @author Wangzy * @date 16:24 2019/12/26 */ public OfficalDocument getOfficalDocument(String key) &#123; OfficalDocument officalDocument = (OfficalDocument) hashtable.get(key); return officalDocument.clone(); &#125;&#125; 123456789101112/** * @author Wangzy * @Description: 公文抽象类 * @date 16:26 2019/12/26 */public interface OfficalDocument extends Cloneable&#123; OfficalDocument clone(); void display();&#125; 12345678910111213141516171819202122232425/** * @author Wangzy * @Description: 软件需求规格说明书 * @date 16:28 2019/12/26 */public class FAR implements OfficalDocument &#123; @Override public OfficalDocument clone() &#123; // 浅克隆 Object object = null; try &#123; object = super.clone(); return (FAR) object; &#125; catch (CloneNotSupportedException e) &#123; System.out.println(\"不支持的克隆类!\"); return null; &#125; &#125; @Override public void display() &#123; System.out.println(\"far display!\"); &#125;&#125; 12345678910111213141516171819202122232425/** * @author Wangzy * @Description: 可行性分析报告 * @date 16:28 2019/12/26 */public class SRS implements OfficalDocument &#123; @Override public OfficalDocument clone() &#123; // 浅克隆 Object object = null; try &#123; object = super.clone(); return (SRS) object; &#125; catch (CloneNotSupportedException e) &#123; System.out.println(\"不支持的克隆类!\"); return null; &#125; &#125; @Override public void display() &#123; System.out.println(\"srs display!\"); &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7424559https://blog.csdn.net/lovelion/article/details/7424594https://blog.csdn.net/lovelion/article/details/7424620https://blog.csdn.net/lovelion/article/details/7424623","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://yoursite.com/tags/创建型模式/"}]},{"title":"单例模式","slug":"singleton-pattern","date":"2019-12-25T03:22:36.000Z","updated":"2019-12-30T08:49:19.720Z","comments":true,"path":"2019/12/25/singleton-pattern/","link":"","permalink":"http://yoursite.com/2019/12/25/singleton-pattern/","excerpt":"设计模式之单例模式定义&emsp;&emsp;单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。","text":"设计模式之单例模式定义&emsp;&emsp;单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。 了解&emsp;&emsp;单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 结构图单例模式是结构最简单的设计模式一，在它的核心结构中只包含一个被称为单例类的特殊类Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 示例 饿汉式单例与懒汉式单例饿汉式12345678class EagerSingleton &#123; private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; &#125; public static EagerSingleton getInstance() &#123; return instance; &#125; &#125; &emsp;&emsp;当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。 懒汉式&emsp;&emsp;懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术避免多线程环境下出现问题（实例化多个对象）: synchronized关键字：可加在类上，也可加在判空后的初始化对象方法上，后者效率更高 双重检查锁定(Double-Check Locking) volatile修饰符：被volatile修饰的成员变量可以确保多个线程都能够正确处理，但volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低 12345678910111213141516171819class LazySingleton &#123; private volatile static LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton getInstance() &#123; //第一重判断 if (instance == null) &#123; //锁定代码块 synchronized (LazySingleton.class) &#123; //第二重判断 if (instance == null) &#123; instance = new LazySingleton(); //创建单例实例 &#125; &#125; &#125; return instance; &#125;&#125; 比较 &emsp;&emsp;饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 &emsp;&emsp;懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。 Initialization Demand Holder (IoDH)1234567891011121314151617181920//Initialization on Demand Holderclass Singleton &#123; private Singleton() &#123; &#125; private static class HolderClass &#123; private final static Singleton instance = new Singleton(); &#125; public static Singleton getInstance() &#123; return HolderClass.instance; &#125; public static void main(String args[]) &#123; Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); System.out.println(s1==s2); &#125;&#125; &emsp;&emsp;在IoDH中，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用&emsp;&emsp;由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。&emsp;&emsp;通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式，但是其与编程语言本身的特性相关，很多面向对象语言不支持IoDH。 总结&emsp;&emsp;单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。 优点 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。 缺点 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。 适用场景 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import javax.xml.crypto.dsig.spec.DigestMethodParameterSpec;import java.util.*;/** * @author Wangzy * @Description: 负载均衡器 * @date 17:01 2019/12/25 */public class LoadBalancer &#123; // 饿汉式单例模式// private static final LoadBalancer loadBalancer = new LoadBalancer(); /** * @Description: （懒汉式单例模式）静态变量引用 volatile 关键字保证确保多个线程都能够正确处理，但volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低 * @author Wangzy * @date 17:53 2019/12/25 */// private volatile static LoadBalancer loadBalancer = null; /** 各个服务器集合 */ private List&lt;String&gt; serverList; /** * @Description: 私有构造方法 * @author Wangzy * @date 17:02 2019/12/25 */ private LoadBalancer() &#123; // 默认负载均衡器自带服务器容器 serverList = new ArrayList&lt;&gt;(); &#125; /** * @Description: 提供整个系统的实例化对象方法 加锁和双重检查锁定都是为了解决多线程产生的问题 * @author Wangzy * @date 17:04 2019/12/25 */// public static LoadBalancer getInstance() &#123;//// if (null == loadBalancer) &#123;//// // 加锁//// synchronized (LoadBalancer.class) &#123;//// // 双重检查锁定//// if (null == loadBalancer) &#123;//// loadBalancer = new LoadBalancer();//// &#125;//// &#125;//// &#125;//// return loadBalancer;//// &#125; /** * @Description: IoDH 要实例化的类不会加载此类；jvm会自动优化线程问题；效率最高，但受语言限制 * @author Wangzy * @date 18:05 2019/12/25 */ private static class ClassHolder &#123; private static final LoadBalancer loadBalancer = new LoadBalancer(); &#125; public static LoadBalancer getInstance() &#123; return ClassHolder.loadBalancer; &#125; /** * @Description: 添加服务器 * @author Wangzy * @date 17:06 2019/12/25 */ public void addServer(String server) &#123; serverList.add(server); &#125; /** * @Description: 移除服务器 * @author Wangzy * @date 17:06 2019/12/25 */ public void removeServer(String server) &#123; serverList.remove(server); &#125; /** * @Description: 查询服务器(负载均衡实现，随机算法) * @author Wangzy * @date 17:06 2019/12/25 */ public String getServer() &#123; List&lt;String&gt; serverList = this.serverList; Random random = new Random(); int i = random.nextInt(serverList.size()); return serverList.get(i); &#125;&#125; 123456789101112131415161718192021222324252627/** * @author Wangzy * @Description: 启动类 * @date 17:12 2019/12/25 */public class Boot &#123; public static void main(String[] args) &#123; // 获取负载均衡服务器（模拟多个用户共享一个实例） LoadBalancer loadBalancer = LoadBalancer.getInstance(); LoadBalancer loadBalancer1 = LoadBalancer.getInstance(); LoadBalancer loadBalancer2 = LoadBalancer.getInstance(); // 判断是否是同一个负载均衡器(是否获取的是同一个实例) if (loadBalancer == loadBalancer1 &amp;&amp; loadBalancer1 == loadBalancer2) &#123; System.out.println(\"服务器负载均衡器具有唯一性！\"); &#125; // 给负载均衡服务器添加服务器 loadBalancer.addServer(\"server1\"); loadBalancer.addServer(\"server2\"); loadBalancer.addServer(\"server3\"); // 模拟客户端请求分发 for (int i = 1; i &lt; 10; i++) &#123; System.out.println(\"分发请求至服务器\" + loadBalancer.getServer() + \"服务器!\"); &#125; &#125;&#125; 相关资料https://blog.csdn.net/lovelion/article/details/7420883https://blog.csdn.net/lovelion/article/details/7420885https://blog.csdn.net/lovelion/article/details/9319423https://blog.csdn.net/lovelion/article/details/7420888https://blog.csdn.net/lovelion/article/details/7420889","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://yoursite.com/tags/创建型模式/"}]},{"title":"抽象工厂模式","slug":"abstract-factory","date":"2019-12-25T03:22:35.000Z","updated":"2019-12-30T08:49:13.865Z","comments":true,"path":"2019/12/25/abstract-factory/","link":"","permalink":"http://yoursite.com/2019/12/25/abstract-factory/","excerpt":"设计模式之抽象工厂模式产品等级结构与产品族&emsp;&emsp;工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。先引入两个概念： 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 定义&emsp;&emsp;抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。","text":"设计模式之抽象工厂模式产品等级结构与产品族&emsp;&emsp;工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是抽象工厂模式的基本思想。如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。先引入两个概念： 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 定义&emsp;&emsp;抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。 了解&emsp;&emsp;当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。 &emsp;&emsp;在上图中可以发现，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，上图所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减少了系统中类的个数。 结构图在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族 AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 重载的工厂方法&emsp;&emsp;与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式对产品对象进行创建。 示例 如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件即可使用新的皮肤，原有代码无须修改，符合“开闭原则” 开闭原则的倾斜性&emsp;&emsp;在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。&emsp;&emsp;正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。 总结&emsp;&emsp;抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。 优点1.抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。 适用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 code123456789101112131415161718192021import javafx.scene.control.Skin;/** * @author Wangzy * @Description: 启动类 * @date 17:45 2019/12/12 */public class Boot &#123; public static void main(String[] args) &#123;// SkinFactory skinFactory = new SpringSkinFactory(); // 通过配置文件方式实现符合“开闭原则”的代码 SkinFactory skinFactory = (SkinFactory) XMLUtil.getBean(); Button button = skinFactory.createButton(); TextField textField = skinFactory.createTextField(); ComboBox comboBox = skinFactory.createComboBox(); button.display(); textField.display(); comboBox.display(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @author Wangzy * @Description: 按钮产品抽象类 * @date 17:32 2019/12/12 */public interface Button &#123; /** * @Description: 显示 * @author Wangzy * @date 17:33 2019/12/12 */ void display();&#125;/** * @author Wangzy * @Description: 复合文本框产品抽象类 * @date 17:34 2019/12/12 */public interface ComboBox &#123; /** * @Description: 显示 * @author Wangzy * @date 17:35 2019/12/12 */ void display();&#125;/** * @author Wangzy * @Description: 文本框产品抽象类 * @date 17:33 2019/12/12 */public interface TextField &#123; /** * @Description: 显示 * @author Wangzy * @date 17:34 2019/12/12 */ void display();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @author Wangzy * @Description: 春天按钮 * @date 17:39 2019/12/12 */public class SpringButton implements Button &#123; @Override public void display() &#123; System.out.println(\"spring button display！\"); &#125;&#125;/** * @author Wangzy * @Description: 春天复合文本框 * @date 17:40 2019/12/12 */public class SpringComboBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"spring combobox display！\"); &#125;&#125;/** * @author Wangzy * @Description: 春天文本框 * @date 17:39 2019/12/12 */public class SpringTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"spring textfield display！\"); &#125;&#125;/** * @author Wangzy * @Description: 夏天按钮 * @date 17:39 2019/12/12 */public class SummerButton implements Button &#123; @Override public void display() &#123; System.out.println(\"summer button display！\"); &#125;&#125;/** * @author Wangzy * @Description: 夏天复合文本框 * @date 17:40 2019/12/12 */public class SummerComboBox implements ComboBox &#123; @Override public void display() &#123; System.out.println(\"summer combobox display！\"); &#125;&#125;/** * @author Wangzy * @Description: 夏天文本框 * @date 17:39 2019/12/12 */public class SummerTextField implements TextField &#123; @Override public void display() &#123; System.out.println(\"summer textfield display！\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @author Wangzy * @Description: 春天界面工厂 * @date 17:36 2019/12/12 */public class SpringSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; System.out.println(\"create spring button！\"); return new SpringButton(); &#125; @Override public TextField createTextField() &#123; System.out.println(\"create spring textfield！\"); return new SpringTextField(); &#125; @Override public ComboBox createComboBox() &#123; System.out.println(\"create spring combobox！\"); return new SpringComboBox(); &#125;&#125;/** * @author Wangzy * @Description: 夏天风格产品工厂 * @date 17:42 2019/12/12 */public class SummerSkinFactory implements SkinFactory &#123; @Override public Button createButton() &#123; System.out.println(\"create summer button！\"); return new SummerButton(); &#125; @Override public TextField createTextField() &#123; System.out.println(\"create summer textfield！\"); return new SummerTextField(); &#125; @Override public ComboBox createComboBox() &#123; System.out.println(\"create summer combobox！\"); return new SummerComboBox(); &#125;&#125; 12345678910111213141516171819202122232425262728/** * @author Wangzy * @Description: 抽象界面工厂 * @date 17:28 2019/12/12 */public interface SkinFactory &#123; /** * @Description: 创建按钮 * @author Wangzy * @date 17:30 2019/12/12 */ Button createButton(); /** * @Description: 创建文本框 * @author Wangzy * @date 17:30 2019/12/12 */ TextField createTextField(); /** * @Description: 创建复合文本框 * @author Wangzy * @date 17:31 2019/12/12 */ ComboBox createComboBox();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243import javax.xml.parsers.*;import org.w3c.dom.*;import org.xml.sax.SAXException;import java.io.*;/** * @author Wangzy * @Description: xml工具类 * @date 17:49 2019/12/12 */public class XMLUtil &#123; /** * @Description: 该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 * @author Wangzy * @date 17:50 2019/12/12 */ public static Object getBean() &#123; try &#123; // 创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\"src/config.xml\")); // 获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(\"className\"); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234&lt;?xml version=\"1.0\"?&gt;&lt;config&gt; &lt;className&gt;SpringSkinFactory&lt;/className&gt;&lt;/config&gt; 相关资料https://blog.csdn.net/lovelion/article/details/9319181https://blog.csdn.net/lovelion/article/details/9319323https://blog.csdn.net/lovelion/article/details/9319423https://blog.csdn.net/lovelion/article/details/9319481https://blog.csdn.net/lovelion/article/details/9319571","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://yoursite.com/tags/创建型模式/"}]},{"title":"工厂方法模式","slug":"factory-methos","date":"2019-12-25T03:22:34.000Z","updated":"2019-12-30T08:49:10.328Z","comments":true,"path":"2019/12/25/factory-methos/","link":"","permalink":"http://yoursite.com/2019/12/25/factory-methos/","excerpt":"设计模式之工厂方法模式定义&emsp;&emsp;工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 了解&emsp;&emsp;在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。","text":"设计模式之工厂方法模式定义&emsp;&emsp;工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。 了解&emsp;&emsp;在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，需要在其中加入必要的业务逻辑，这违背了“开闭原则”。此外，在简单工厂模式中，所有的产品都由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性，而工厂方法模式则可以很好地解决这一问题。在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。 结构图工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。 Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。 ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 示例 重载的工厂方法&emsp;&emsp;在抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。当然，对于同一个具体工厂而言，无论使用哪个工厂方法，创建的产品类型均要相同。 example: 工厂方法的隐藏&emsp;&emsp;有时候，为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法。 总结&emsp;&emsp;工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。 优点 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 适用场景 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 code12345678910111213141516171819/** * @author Wangzy * @Description: 启动类 * @date 15:52 2019/12/12 */public class Boot &#123; public static void main(String[] args) &#123; // 获取工厂// LoggerFactory factory = new DatebaseLoggerFactory();// LoggerFactory factory = new FileLoggerFactory();// Logger logger = factory.createLogger();// logger.writeLogger(); // 读取配置文件生成类 LoggerFactory factory = (LoggerFactory) XMLUtil.getBean(); Logger logger = factory.createLogger(); logger.writeLogger(); &#125;&#125; 123456789101112/** * @author Wangzy * @Description: 数据库记录日志 * @date 15:50 2019/12/12 */public class DatebaseLogger implements Logger &#123; @Override public void writeLogger() &#123; System.out.println(\"write datebase log!\"); &#125;&#125; 123456789101112131415161718192021222324/** * @author Wangzy * @Description: 数据方式记录日志工厂类 * @date 15:49 2019/12/12 */public class DatebaseLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; System.out.println(\"create datebase log!\"); return new DatebaseLogger(); &#125; @Override public Logger createLogger(String args) &#123; return null; &#125; @Override public Logger createLogger(Object obj) &#123; return null; &#125;&#125; 12345678910111213/** * @author Wangzy * @Description: 文件方式 * @date 15:47 2019/12/12 */public class FileLogger implements Logger &#123; @Override public void writeLogger() &#123; System.out.println(\"write file log!\"); &#125;&#125; 12345678910111213141516171819202122232425/** * @author Wangzy * @Description: 文件记录日志方式工厂 * @date 15:45 2019/12/12 */public class FileLoggerFactory implements LoggerFactory &#123; @Override public Logger createLogger() &#123; System.out.println(\"create file method!\"); return new FileLogger(); &#125; @Override public Logger createLogger(String args) &#123; System.out.println(\"create file method by args!\"); return new FileLogger(); &#125; @Override public Logger createLogger(Object obj) &#123; return null; &#125;&#125; 1234567891011121314/** * @author Wangzy * @Description: 抽象产品 * @date 15:45 2019/12/12 */public interface Logger &#123; /** * @Description: 记录日志 * @author Wangzy * @date 15:48 2019/12/12 */ void writeLogger();&#125; 12345678910111213141516171819202122232425262728293031323334/** * @author Wangzy * @Description: 抽象工厂 * @date 15:42 2019/12/12 */public interface LoggerFactory &#123; /** * @Description: 创建工厂 * @author Wangzy * @date 15:43 2019/12/12 */ Logger createLogger(); /** * @Description: 抽象工厂中定义多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。 * @author Wangzy * @date 16:23 2019/12/12 */ Logger createLogger(String args); Logger createLogger(Object obj); /** * @Description: 在抽象工厂类（abstract class）中将直接调用产品类的业务方法，客户端无须调用工厂方法创建产品，直接通过工厂即可使用所创建的对象中的业务方法 * @author Wangzy * @date 16:32 2019/12/12 */// public void writeLog() &#123;// Logger logger = this.createLogger();// logger.writeLogger();// &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;/** * @author Wangzy * @Description: XML工具类 * @date 16:07 2019/12/12 */public class XMLUtil &#123; /** * @Description: 该方法用于从XML配置文件中提取具体类类名，并返回一个实例对象 * @author Wangzy * @date 16:09 2019/12/12 */ public static Object getBean() &#123; try &#123; // 创建DOM文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\"src/config.xml\")); // 获取包含类名的文本节点 NodeList nl = doc.getElementsByTagName(\"className\"); Node classNode = nl.item(0).getFirstChild(); String cName = classNode.getNodeValue(); // 通过类名生成实例对象并将其返回 Class c = Class.forName(cName); Object obj = c.newInstance(); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234&lt;?xml version=\"1.0\"?&gt;&lt;config&gt; &lt;className&gt;FileLoggerFactory&lt;/className&gt;&lt;/config&gt; 相关资料https://blog.csdn.net/lovelion/article/details/9306457https://blog.csdn.net/lovelion/article/details/9306745https://blog.csdn.net/lovelion/article/details/9307137https://blog.csdn.net/lovelion/article/details/9307561","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://yoursite.com/tags/创建型模式/"}]},{"title":"简单工厂模式","slug":"simple-pattern","date":"2019-12-25T03:22:33.000Z","updated":"2019-12-30T08:49:04.379Z","comments":true,"path":"2019/12/25/simple-pattern/","link":"","permalink":"http://yoursite.com/2019/12/25/simple-pattern/","excerpt":"设计模式之简单工厂模式定义&emsp;&emsp;简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。 了解&emsp;&emsp;简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础。简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计。","text":"设计模式之简单工厂模式定义&emsp;&emsp;简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。 了解&emsp;&emsp;简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础。简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计。 结构图 &emsp;&emsp;Factory：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。&emsp;&emsp;Product：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。&emsp;&emsp;ConcreteProduct：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法 示例 简化&emsp;&emsp;为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在JDK等类库和框架中也广泛存在。 总结优点 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用场景 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 code123456789101112131415/** * @author Wangzy * @Description: 启动类 * @date 10:55 2019/12/12 */public class Boot &#123; public static void main(String[] args) &#123; // 配置文件读取图表类型，无需修改客户端代码，符合开闭原则 String chartType = XMLUtils.getChartType(); Chart chart = ChartFactory.getChart(chartType);// Chart chart = Chart.factoryMethod(chartType); chart.show(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * @author Wangzy * @Description: 抽象图表类 * @date 10:50 2019/12/12 */public interface Chart &#123; /** * @Description: 显示方法 * @author Wangzy * @date 10:50 2019/12/12 */ void show(); /** * @Description: 通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在JDK等类库和框架中也广泛存在 * @author Wangzy * @date 11:24 2019/12/12 */// static Chart factoryMethod(String charttype) &#123;// Chart chart = null;// // 柱状图// if (\"histogram\".equals(charttype)) &#123;// System.out.println(\"create histogram chart!\");// chart = new HistogramChart();// // 饼状图// &#125; else if (\"pie\".equals(charttype)) &#123;// System.out.println(\"create pie chart!\");// chart = new PieChart();// // 折线图// &#125; else if (\"line\".equals(charttype)) &#123;// System.out.println(\"create line chart!\");// chart = new LineChart();// &#125;// return chart;// &#125;&#125; 123456789101112131415161718192021222324252627282930/** * @author Wangzy * @Description: 简单工厂类 * @date 10:42 2019/12/12 */public class ChartFactory &#123; /** * @Description: 创建不同形式的图表 * @author Wangzy * @date 10:43 2019/12/12 */ public static Chart getChart(String charttype) &#123; Chart chart = null; // 柱状图 if (\"histogram\".equals(charttype)) &#123; System.out.println(\"create histogram chart!\"); chart = new HistogramChart(); // 饼状图 &#125; else if (\"pie\".equals(charttype)) &#123; System.out.println(\"create pie chart!\"); chart = new PieChart(); // 折线图 &#125; else if (\"line\".equals(charttype)) &#123; System.out.println(\"create line chart!\"); chart = new LineChart(); &#125; return chart; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author Wangzy * @Description: 柱状图具体类 * @date 10:51 2019/12/12 */public class HistogramChart implements Chart &#123; public HistogramChart() &#123; System.out.println(\"init histogram chart!\"); &#125; @Override public void show() &#123; System.out.println(\"show histogram chart!\"); &#125;&#125;/** * @author Wangzy * @Description: 折线图具体类 * @date 10:51 2019/12/12 */public class LineChart implements Chart &#123; public LineChart() &#123; System.out.println(\"init line chart!\"); &#125; @Override public void show() &#123; System.out.println(\"show line chart!\"); &#125;&#125;/** * @author Wangzy * @Description: 饼图具体类 * @date 10:51 2019/12/12 */public class PieChart implements Chart &#123; public PieChart() &#123; System.out.println(\"init pie chart!\"); &#125; @Override public void show() &#123; System.out.println(\"show pie chart!\"); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738import javax.xml.parsers.*;import org.w3c.dom.*;import java.io.*;/** * @author Wangzy * @Description: 读取配置文件工具类 * @date 11:13 2019/121/12 */public class XMLUtils &#123; /** * @Description: 该方法用于从XML配置文件中提取图表类型，并返回类型名 * @author Wangzy * @date 11:14 2019/12/12 */ public static String getChartType() &#123; try &#123; // 创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File(\"src/config.xml\")); // 获取包含图表类型的文本节点 NodeList nl = doc.getElementsByTagName(\"chartType\"); Node classNode = nl.item(0).getFirstChild(); String chartType = classNode.getNodeValue().trim(); return chartType; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 1234&lt;?xml version=\"1.0\"?&gt;&lt;config&gt; &lt;chartType&gt;histogram&lt;/chartType&gt;&lt;/config&gt; 相关资料https://blog.csdn.net/lovelion/article/details/9300337https://blog.csdn.net/lovelion/article/details/9300549https://blog.csdn.net/lovelion/article/details/9300657https://blog.csdn.net/lovelion/article/details/9300731","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"创建型模式","slug":"创建型模式","permalink":"http://yoursite.com/tags/创建型模式/"}]},{"title":"面向对象设计原则之迪米特法则","slug":"lod","date":"2019-12-24T10:11:07.000Z","updated":"2019-12-25T03:17:39.990Z","comments":true,"path":"2019/12/24/lod/","link":"","permalink":"http://yoursite.com/2019/12/24/lod/","excerpt":"","text":"面向对象设计原则之迪米特法则定义迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。 了解&emsp;&emsp;如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。&emsp;&emsp;应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 注意事项&emsp;&emsp;在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 示例old new 相关资料https://blog.csdn.net/LoveLion/article/details/17517213","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之合成复用原则","slug":"crp","date":"2019-12-24T10:11:06.000Z","updated":"2019-12-25T03:17:27.083Z","comments":true,"path":"2019/12/24/crp/","link":"","permalink":"http://yoursite.com/2019/12/24/crp/","excerpt":"","text":"面向对象设计原则之合成复用原则定义合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。 了解&emsp;&emsp;合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。&emsp;&emsp;在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。&emsp;&emsp;通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。&emsp;&emsp;由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7563441","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之接口隔离原则","slug":"isp","date":"2019-12-24T10:11:05.000Z","updated":"2019-12-25T03:16:55.766Z","comments":true,"path":"2019/12/24/isp/","link":"","permalink":"http://yoursite.com/2019/12/24/isp/","excerpt":"","text":"面向对象设计原则之接口隔离原则定义接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 了解&emsp;&emsp;根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的1. interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同： 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 注意事项&emsp;&emsp;在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7562842","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之依赖倒转原则","slug":"dip","date":"2019-12-24T10:11:04.000Z","updated":"2019-12-25T03:17:13.478Z","comments":true,"path":"2019/12/24/dip/","link":"","permalink":"http://yoursite.com/2019/12/24/dip/","excerpt":"","text":"面向对象设计原则之依赖倒转原则定义&emsp;&emsp;依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 了解&emsp;&emsp;依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。&emsp;&emsp;在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。&emsp;&emsp;在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7562783","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之里氏代换原则","slug":"lsp","date":"2019-12-24T10:11:03.000Z","updated":"2019-12-25T03:16:26.702Z","comments":true,"path":"2019/12/24/lsp/","link":"","permalink":"http://yoursite.com/2019/12/24/lsp/","excerpt":"","text":"面向对象设计原则之里氏代换原则定义&emsp;&emsp;里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。&emsp;&emsp;严格表述：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。 了解&emsp;&emsp;里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。&emsp;&emsp;例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。&emsp;&emsp;里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 注意事项 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7540445","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之开闭原则","slug":"ocp","date":"2019-12-24T10:11:02.000Z","updated":"2019-12-25T03:16:40.462Z","comments":true,"path":"2019/12/24/ocp/","link":"","permalink":"http://yoursite.com/2019/12/24/ocp/","excerpt":"","text":"面向对象设计原则之开闭原则定义&emsp;&emsp;开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 ###了解&emsp;&emsp;任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。&emsp;&emsp;为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。如在java中可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7537584","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"面向对象设计原则之单一职责原则","slug":"srp","date":"2019-12-24T10:11:01.000Z","updated":"2019-12-25T03:09:29.805Z","comments":true,"path":"2019/12/24/srp/","link":"","permalink":"http://yoursite.com/2019/12/24/srp/","excerpt":"","text":"面向对象设计原则之单一职责原则定义&emsp;&emsp;单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 了解&emsp;&emsp;在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 示例old new 相关资料https://blog.csdn.net/lovelion/article/details/7536542","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Spring Boot","slug":"springboot01","date":"2019-12-19T02:55:01.000Z","updated":"2019-12-19T02:55:50.115Z","comments":true,"path":"2019/12/19/springboot01/","link":"","permalink":"http://yoursite.com/2019/12/19/springboot01/","excerpt":"初识Spring Boot一. Spring的java配置方式Spring4.x推荐的配置方式，可以完全替代xml配置, 常用注解: @Configuration（作用于类上，相当于一个xml配置文件）； @Bean（作用于方法上，相当于xml配置中的bean标签） @ComponentScan（basePackages = &quot;配置类所在包&quot;） @PropertySource（value=&quot;指定配置文件&quot;，ignoreResourceNotFound = true） @Value（&quot;${key}&quot;）获取配置文件中的值 二. Spring Boot &emsp;&emsp;“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，无需手动），项目独立运行（运行jar，内嵌Servlet容器），使用它可以不用或只需要很少的Spring配置。","text":"初识Spring Boot一. Spring的java配置方式Spring4.x推荐的配置方式，可以完全替代xml配置, 常用注解: @Configuration（作用于类上，相当于一个xml配置文件）； @Bean（作用于方法上，相当于xml配置中的bean标签） @ComponentScan（basePackages = &quot;配置类所在包&quot;） @PropertySource（value=&quot;指定配置文件&quot;，ignoreResourceNotFound = true） @Value（&quot;${key}&quot;）获取配置文件中的值 二. Spring Boot &emsp;&emsp;“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，无需手动），项目独立运行（运行jar，内嵌Servlet容器），使用它可以不用或只需要很少的Spring配置。 常用注解 @SpringBootApplication（核心注解，用于开启自动配置） 注：自动配置的东西会很多，若想关闭某一项配置 @SpringBootApplication(exclude = {RedisAutoConfiguration.class}) 手动关闭Redis配置 @Configuration @ConditionalOnMissingBean（当容器里没有指定的Bean的情况下创建该对象） @AutoConfigureAfter（*.class）保证在括号内的类实例化完成之后在实例化该类，注解加在类上 注： @ResponseBody：两个作用，首先，将响应结果直接写入HTTP response body中，不会被解析为跳转路径；直接将响应结果以json形式返回； 启动应用通过main方法启动，启动类应在被扫描包的同级或上级包里 全局配置文件 &emsp;&emsp;application.properties 或 application.yml,可以放在resources目录下或者类路径下的/config下，一般是放到resources目录下的 比如：修改tomcat的端口为8088server.port=8088,更多的配置在文件里有参考 Starter pom &emsp;&emsp;个人理解为SpringBoot为我们提供了绝大多数的配置，放置在parent里面，应用的时候，根据具体的业务场景导入相应的依赖也就是Starter pom，就可以实现零配置使用默认配置好的bean，也可以在全局配置里修改默认的配置。 xml配置文件 &emsp;&emsp;可能有一些特殊要求必须使用xml配置，应用注解@ImportResource来加载xml配置 注: &emsp;&emsp;在进行SpringApplication对象实例化的时候会加载META-INF/spring.factories文件，并将该配置文件载入到Spring容器 自定义配置 &emsp;&emsp;如：SpringMVC配置，比如增加一个拦截器，这个时候可以通过继承WebMvcConfigurerAdapter然后重写父类中的方法进行扩展。 事务的配置 &emsp;&emsp;在引入jdbc依赖之后，直接使用@Transactional注解即可，可加在类上，也可以加在方法上 注：内嵌的tomcat是不支持jsp页面的，因此应导入额外的包才能解决 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"Linux命令","slug":"linux02","date":"2019-12-19T02:54:01.000Z","updated":"2019-12-19T02:54:37.427Z","comments":true,"path":"2019/12/19/linux02/","link":"","permalink":"http://yoursite.com/2019/12/19/linux02/","excerpt":"一. Linux命令格式command 【-options】 【parameter1】… 注: &emsp;&emsp;command：命令名，相应功能的英文单词或单词的缩写 &emsp;&emsp;【-options】：选项，可用来对命令进行控制，也可以省略 &emsp;&emsp;【parameter】：传给命令的参数，可以是0个1个或多个 &emsp;&emsp;[]里的内容是代表可选","text":"一. Linux命令格式command 【-options】 【parameter1】… 注: &emsp;&emsp;command：命令名，相应功能的英文单词或单词的缩写 &emsp;&emsp;【-options】：选项，可用来对命令进行控制，也可以省略 &emsp;&emsp;【parameter】：传给命令的参数，可以是0个1个或多个 &emsp;&emsp;[]里的内容是代表可选 二. 查看帮助文档1. command –help2. man(manual)注: &emsp;&emsp;man是linux提供的一个手册，包含了绝大部分的命令以及函数使用说明涉及到功能键及功能： 空格： 显示手册页的下一屏 Enter：一次滚动手册页的一行 b： 回滚一屏 f： 前滚一屏 q： 退出 h： 列出所有功能键 /word：搜索word字符串 三. 历史命令上下键或用history将执行过的命令列举出来 四. Linux命令–文件, 磁盘管理1. ll&amp;ls1.1 文件管理 ls 查看文件信息 注: 以.(点)开头的文件为隐藏文件， 需要用-a参数才能显示-a 显示制定目录下所有子目录与文件，包括隐藏文件-l 以列表方式显示文件的详细信息-h 配合-l以人性化的方式显示文件大小其实一个ll解决一切 1.2 通配符 &emsp;&emsp;*（星号）代表文件名中所有字符,?（问号）代表文件名中任意一个字符,[] (方括号) 将字符组括起来，表示可以匹配字符组中的任意一个。其中‘-（中杠）’表示字符范围. &emsp;&emsp;如： ls [a-f]* 查找并显示a到f范围内的任意一个字符开头的文件\\ (反斜杠) 如果想使通配符作为普通字符用，可以在其前面加上转义字符。另外‘?’和‘*’处于方括号内时不需要使用转义字符就失去了通配符的作用如： ls *a 查找文件名为*a的文件 2. 输出重定向命令：&gt;&emsp;&emsp;将命令执行结果重定向到一个文件， 本应该显示在终端上的内容保存到制定文件中 &emsp;&emsp;如： ls &gt; test.txt(文件若不存在，则创建，若存在则覆盖其中的内容) &emsp;&emsp;注： 可以用cat查看文件的内容，&gt; 输出重定向会覆盖原来的内容， &gt;&gt; 输出重定向则会追加到文件的尾部 3. 分屏显示: more&emsp;&emsp;查看内容时， 在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按空格键可以显示下一页，按q键退出显示，按h键获取帮助。 4. 管道: |&emsp;&emsp;什么是管道，就是一个命令的输出可以通过管道作为另一个命令的输入，通俗一点来讲就是将查寻到或者其他方式得到的数据放到所谓的管道里面，然后对数据继续进行操作 5. 清屏：clear或Ctrl + l6. 切换工作目录： cd&emsp;&emsp;其后可以跟绝对路径，也可以跟相对路径，如果省略目录的话，就默认切换到当前用户的主目录（此时相当于cd~） cd . 切换到当前目录 cd .. 切换到上级目录 cd - 切换到上次所在的目录 注: &emsp;&emsp;Linux所有的目录和文件名大小写敏感，如果路径是从根据径开始的，其前面需要加上‘/’， 而通常进入某个目录里的文件夹，前面不需要加 7. 显示当前路径： pwd8. 创建目录：mkdir参数-p可递归创建目录 &emsp;&emsp;注意新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写的权限 tree： 以目录树的方式显示，显示文件夹层级关系是极好的 9. 删除目录：rmdir10. 删除文件： rmrm可以删除文件和目录。 注意： 文件删除后是不能恢复的，为了防止文件误删，可以在rm后使用-i参数来逐个确认要删除的文件 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归删除目录下的内容，删除文件夹时必须加这个参数 11. 建立链接文件: ln(了解一下)类似与Windows下的快捷方式，分为软连接和硬链接 11.1 软连接：不占用磁盘空间，源文件删除软链接就失效 格式: ln -s 源文件 链接文件 11.2 硬链接: 只能链接普通文件，不能链接目录 格式: ln 源文件 链接文件 注: &emsp;&emsp;建立起的硬链接文件，两个文件占用相同大小的磁盘空间，即使删除了源文件，链接文件还是存在的，因此类似于Windows的快捷方式，软连接是更常见的一种形式； 另外，如果软连接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径 12. 查看或者合并文件内容：cat例如: cat test.txt test2.txt &gt; helloworld.txt 注: &emsp;&emsp;linux的文件不是通过后缀区分的，不一定非是*.txt才是文本文件，通常通过文件的颜色就能区分出是文件或者文件夹 13. 文本搜索: grep是一个强大的文本搜索工具，允许对文本文件进行模式查找。如果找到匹配模式，grep打印包含模式的所有行 13.1 一般格式 grep [-选项] &apos;搜索内容串&apos;文件名 注: &emsp;&emsp;在grep命令中输入字符串参数时，最好用引号括起来，如：grep ‘a’ text.txt,另，linux里是不区分单引号还是双引号的 13.2 常规选项说明 -v: 显示不包含匹配文本的所有行（相当于求反） -n: 显示匹配行及行号 -i: 忽略大小写 注: grep搜索的内容串也可以是正则表达式 14. 查找文件：find&emsp;&emsp;通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件常用语法： 15. 拷贝文件 cp其主要功能是将给出的文件或目录复制到另一个文件或目录中 常用选项: -a：该选项通常在复制目录时使用，它会保留链接，文件属性，并递归地复制目录，简而言之，保持文件的原有属性 -f：已经存在的目标文件而不提示，直接覆盖 -i：交互式复制，在覆盖目标文件之前给出提示要求用户确认 -r：若给出的源文件时目录文件，则cp将递归复制该目录下所有的子目录和文件，目标文件必须为一个目录名 -v：显示拷贝进度 16. 移动文件 mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名 常用选项: -f：禁止交互式操作，即使有覆盖也不给出提示 -i：交互式操作 -v: 显示移动进度 17. 归档管理 tar&emsp;&emsp;tar是Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，亦可以将档案文件解开以恢复数据 17.1 使用格式 tar [参数] 打包文件名 文件 注: tar命令的参数前面既可以使用‘-’，也可以不使用 17.2 常用参数: -z：制定压缩包的格式为：file.tar.gz -c：生成档案文件，创建打包文件 -v：列出归档解档的详细过程，显示进度 -t：列出档案中包含的文件 -x：解开档案文件 -f：指定档案文件名称，f后面一定是.tar文件，因此务必要放选项最后，但其他参数随意 18. 文件压缩与解压缩 gzip&emsp;&emsp;tar与gzip命令结合使用方可实现文件打包，压缩。tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxx.tar.gz 18.1 使用格式: gzip [选项] 被压缩文件 18.2 常用选项: -d：解压 -r：压缩所有子目录（默认不加选项也是压缩） 注：上面的其实没多大卵用，并且麻烦的雅痞，因此在tar命令中增加了一个选项（-z），此时就可以调用gzip从而实现一个压缩的功能，完成先打包后压缩的过程 18.3 压缩用法 tar -zcvf 压缩包包名 文件1 文件2... 注：不同的压缩方式算法不同，因此压缩的速度以及大小均不同，综合起来而言，推荐使用的是tar -zcvf 18.4 解压缩用法 tar -zxvf 压缩包包名 注：默认是解压到当前路径下，要解压到指定目录下可以用选项‘-C’ 19. 文件压缩与解压缩 bzip2&emsp;&emsp;其用法和gzip一样，压缩文件的扩展名一般用：xxx.tar.gz2, 具体实现方式在tar命令中增加一个（-j）选项即可 压缩及解压缩用法： 如： tar -jcvf demo.tar.bz2 *.test tar -jxvf demo.tar.bz2 20. 文件压缩与解压缩：zip 、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 压缩及解压缩用法： zip [-r] 目标文件（无需扩展名） 源文件 unzip -d 解压后目录文件 压缩文件 21. 查看命令位置 which&emsp;&emsp;如果找到就显示这个命令的路径，找不到就不显示呗，了解一下，没什么卵用 五. Linux命令-系统管理1. 查看当前日历 cal（-y显示整年）2. 显示或设置时间： date2.1 设置时间格式(需要管理员权限) date [MMDDhhmm[[CC]YY][.ss]] +format 注：CC为年前两位yy为年的后两位，前两位的mm为⽉，后两位的mm为分钟，dd为天，hh为 ⼩时，ss为秒。如： date 010203042016.55。 2.2 显示时间格式 date &apos;+%y,%m,%d,%H,%M,%S&apos; 如：date &apos;+%Y/%m/%d&apos; ==&gt;xxxx/xx/xx 注：y/Y效果一样 3. 查看进程信息 ps此命令可以查看进程的详细状况 常用选项（‘-可以省略’）: -a：显示终端上的所有进程，包括其他用户的进程 -u：显示进程的详细状态 -x：显示没有控制终端的进程 -w：显示加宽，以便显示更多的信息 -r：只显示正在运行的进程 4. 动态显示进程 top&emsp;&emsp;用来动态显示运行中的进程，能够再运行之后，在指定的时间间隔更新显示信息，可以通过加选项[-d]来指定显示信息更新的时间间隔 常用按键： M：根据内存使用量排序 P：根据CPU占有率排序 T：根据进程运行时间长短排序 U：根据后面输入的用户名来筛选进程 K：根据后面输入的PID杀死进程 q：退出 h：帮助 5. 终止进程：kill 杀死指定进程号的进程，需要配合ps使用 格式: kill [-signal] pid 注: 其中信号值选项从0到15，9为绝对终止，可以处理一般信号无法终止的进程 6. 关机重启：reboot、shutdown、init如: reboot 重新启动操作系统 shutdown -h now 立刻关机 shutdown -h 20:25 定时关机 shutdown -h +10 系统过十分钟自动关机 init 0 关机 init 6 重启 7. 检测磁盘空间: df&emsp;&emsp;用于检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况 常用选项： -a：显示所有文件系统的磁盘使用情况 -m：以1024字节为单位显示 -t：显示各指定文件系统的磁盘空间使用情况 -T：显示文件系统 8. 检测目录所占磁盘空间：du&emsp;&emsp;用于统计目录或文件所占磁盘空间的大小，该命令的执行结果与df类似，du更测重于磁盘的使用情况 格式: du [选项] 目录或文件名 -a：递归显示指定目录中各文件和子目录中文件占用的数据块 -s：显示指定文件或目录占用的数据块 -b：以字节为单位显示磁盘占用情况 -l：计算所有文件大小，对硬链接文件计算多次 注：在后面加-h可以转换单位，如：du -s build/ -h 显示指定文件占用的数据块，并转换单位 9. 查看或配置网卡信息：ifconfig默认显示所有的网卡信息 &emsp;&emsp;另外，修改网卡的ip地址信息：ifconfig + 网卡名 + 新ip地址，如果权限不足，加sudo，或者通过sudo su切换到root用户操作 10. 测试远程主机联通性：pingping www.baidu.com ping 192.168.1.1 六. Linux命令-用户、权限管理&emsp;&emsp;用户管理包括用户与组账号的管理，无论是由本机或是远程登陆系统，每个系统必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限，root是用于系统的维护和管理的，拥有不受限制的访问权限；再Linux的安装过程中系统会自动创建许多用户账号，这些默认被创建的用户称为‘标准用户’，通常不推荐直接使用root账号登陆系统 1. 查看当前用户：whoami&emsp;&emsp;用户可以使用该命令查看当前系统当前账号的用户名，还可以通过cat /etc/passwd查看系统用户信息 2. 查看登陆用户：who用于查看当前所有登录系统的用户信息，通俗点就是谁登陆了此系统都会显示出来 常用选项: -m或am I ：只显示运行who命令的用户名、登陆终端和登陆时间 -q或--count：只显示用户的登陆账号和登陆用户的数量 -u或--heading：显示列标题 3. 退出登陆用户：exit如果是图形界面，退出当前终端； 如果是使用ssh远程登陆，退出登陆用户； 如果是切换后的登陆用户，退出并返回上一个登陆账号 4. 添加用户账号 useradd使用格式： useradd [选项] 新建用户账号 常用选项: -d：指定用户登陆系统时的主目录，如果不使用该参数，系统就自动再/home目录下面建立与用户名同名目录作为主目录 -m：自动建立目录 -g：指定组名称 注：adduser的命令是指向useradd的一个链接，两个命令的格式完全一样，作用也是一样的； Linux每个用户都有一个主目录，主目录即第一次登陆系统，用户的默认当前目录 （/home/user）； 创建用户的时候，一定要给用户指定一个主目录，因为每一个用户必须要有一个主目录； 用户的主目录一般要放在根目录的home目录下，用户的主目录和用户名是相同的，走默认的即可，前面的约等于扯犊子； 如果创建用户的时候没有指定组名，那么系统也会自动创建一个和用户名一样的组名 一句话，走默认，就够了 如：useradd -d /home/a a -g test 创建一个用户名字叫a，主目录在/home/a, 如果主目录不存在，就自动创建主目录，同时用户属于test组 5. 设置用户密码 passwd&emsp;&emsp;超级用户可以使用passwd命令为普通用户设置或修改用户口令；用户也可以直接使用该命令来修改自己的口令，并且不需要在命令后面使用用户名 6. 删除用户 userdel常用格式： userdel abc : 删除abc用户，但并不会自动删除用户的主目录 userdel -r abc : 删除用户同时删除用户的主目录 7. 切换用户 su&emsp;&emsp;通过此命令切换用户，后面也可以加‘-’中杠，其作用是在切换到对应的用户时会将当前的工作目录自动转换到切换后的用户主目录 注: &emsp;&emsp;在命令前加‘sudo’ 允许系统管理员让普通用户执行全部root权限命令，减少了root用户的登陆和管理时间；（sudo）su 默认切换到root用户；$表示普通用户， #表示root用户 8. 查看有哪些用户组method1: cat /etc/group method2: groupmod + 三次tab键 9. 添加、删除组账号 groupadd groupdel格式: groupadd / groupdel + 组账号 注：一般会报权限不足，应在命令前加sudo 10. 修改用户所在的组 usermod格式: usermod -g 用户组 用户名 注: 查询是否修改成功 cat /etc/group | grep XXX 11. 查看用户在哪些组 groups 12. 为创建的普通用户添加sudo权限sudo usermod -a -G adm 用户名 sudo usermod -a -G sudo 用户名 注：usermod -g 与 -G的区别 -g：用来指定这个用户默认的用户组 -G：一般配合-a来完成向其它组添加 13. 修改文件权限 chmod13.1 字母法： 注： u（user）表示该文件的所有者 g（group）表示与该文件的所有者属于同一组者，也即用户组 o（other） 表示其他以外的用户 a（all） 表示所有，包括以上三者 + 增加权限 - 撤销权限 = 设定权限 13.2 数字法: rwx这些权限是可以用数字来代替的 r：读取权限，数字代号为4 w：写入权限，数字代号为2 x：执行权限，数字代号为1 -：不具备任何权限，数字代号为0 如：执行chmod u=rwx，g=rx, o=r filename等同于：chmod u=7,g=5,o=4 filename也等同于 chmod 751 filename； 另，若想递归所有目录加上相同权限，需加上参数‘-R’ 如：chmod 777 test/ -R 可递归test目录下所有文件并加777权限 14. 修改文件所有者 chown格式： chown + 文件所有者 + 文件名 15. 修改文件所属组 chgrp格式：chgrp + 文件所属组 + 文件名 七. Vim编辑器及相关命令&emsp;&emsp;vi（Visual interface）,即可视化界面，分为三种基本工作模式：命令模式、文本输入模式、末行模式vim是从vi发展出来的一个文本编辑器，下面为它的基础操作 1. 进入插入模式:i：插入光标前一个字符 I：插入行首 a：插入光标后一个字符 A：插入行末 o：向下新开一行，插入行首 O：向上新开一行，插入行首 2. 进入命令模式：ESC：会从插入模式或末行模式进入命令模式 3. 移动光标：h: 左移 j: 下移 k: 上移 l: 右移 M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行,行号 -G w: 向后一次移动一个字 b: 向前一次移动一个字 {: 按段移动,上移 }: 按段移动,下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏 gg: 光标移动文件开头 G: 光标移动到文件末尾 4. 删除命令x: 删除光标后一个字符,相当于 Del X: 删除光标前一个字符,相当于 Backspace dd: 删除光标所在行,n dd 删除指定的行数 D: 删除光标后本行所有内容,包含光标所在字符 d0: 删除光标前本行所有内容,不包含光标所在字符 dw: 删除光标开始位置的字,包含光标所在字符 5. 撤销命令u：一步步撤销 Ctrl - r：反撤销 6. 重复命令.(点): 重复上一次操作的命令 7. 文本行移动&gt;&gt;: 文本行右移 &lt;&lt;: 文本行左移 8. 复制粘贴yy：复制当前行，n yy 复制n行 p：在光标所在位置向下开辟一行并粘贴 9. 可视模式v：按字符移动，选中文本 V：按行移动，选中文本可视模式可以配合d，y，&gt;&gt;, &lt;&lt;实现对文本块的删除，复制以及左右移动 10. 替换操作r：替换当前字符 R：替换当前行光标后的字符 11. 查找命令/：str查找 n：下一个 N：上一个 12. 替换命令如：把abc全部替换成123 末行模式下，将当前文件中的所有abc替换成123 ：%s/abc/123/g 末行模式下，将第一行至第10行之间的abc替换成123 ：1，10s/abc/123/g 注: 若在vim里执行shell下命令，可以通过在末行模式里输入！，后面跟命令即可 八. 分屏操作(进阶)1. 常用分屏操作:sp：上下分屏，后可跟文件名 vsp：左右分屏，后可跟文件名 Ctrl+w+w：在多个窗口切换 2. 启动分屏:2.1 使用大写O选项进行垂直分屏 格式：vim -On file1 file2 ... 2.2 使用小写o参数进行水平分屏 格式：vim -on file1 file2 ... 注：n是数字，表示分屏的数量，要保证n大于等于文件的个数 3. 关闭分屏:3.1 关闭当前窗口 Ctrl + w c 3.2 关闭当前窗口，如果只剩最后一个，则退出vim Ctrl + w a 4. 编辑中分屏4.1 上下分割当前打开的文件 Ctrl+w s 4.2 上下分割，并打开一个新的文件 ：sp filename 4.3 左右分割当前打开的文件 ctrl+w v 4.4 左右分割，并打开一个新的文件 ：vsp filename 5. 分屏编辑中光标的移动&emsp;&emsp;vi中的光标键是h，j，k，l，要想在各个屏之间切换，只需要先按一下Ctrl+w 把光标移动到上边的屏 ctrl + w k 把光标移动到下一个屏 ctrl + w w 6. 移动分屏如: 向上移动：ctrl+w K(大写，其他参考光标键) 7. 屏幕尺寸7.1 增加高度 ctrl+w + 7.2 减少高度 ctrl+w - 7.3 让所有的屏高度一致 ctrl+w = 7.4 左加宽度 ctrl+w &gt; 7.5 右加宽度 ctrl+w &lt; 7.6 右增加n宽(如: n = 30) ctrl + w n &lt;","categories":[{"name":"linux学习","slug":"linux学习","permalink":"http://yoursite.com/categories/linux学习/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"初识Linux","slug":"linux01","date":"2019-12-19T02:53:01.000Z","updated":"2019-12-19T02:53:59.200Z","comments":true,"path":"2019/12/19/linux01/","link":"","permalink":"http://yoursite.com/2019/12/19/linux01/","excerpt":"Linux系统没有盘符的概念, 只有一个根目录”/“, 所有的文件都在这个根目录下面 一. 目录1. “/“&emsp;&emsp;根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西 都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目 录）开始，再进入到home目录。","text":"Linux系统没有盘符的概念, 只有一个根目录”/“, 所有的文件都在这个根目录下面 一. 目录1. “/“&emsp;&emsp;根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西 都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目 录）开始，再进入到home目录。 2. /bin、/usr/bin&emsp;&emsp;可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 3. /dev&emsp;&emsp;存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备， 常用的是挂载光驱 mount /dev/cdrom /mnt。 4. /etc&emsp;&emsp;系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文 件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d等。 5. /home&emsp;&emsp;系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录 下，~表示当前用户的家目录，如: ~edu 表示用户 edu 的家目录。 6. /lib、/usr/lib、/usr/local/lib&emsp;&emsp;系统使用的函数库的目录，程序在执行过程中，需要调 用一些额外的参数时需要函数库的协助。 7. /lost+fount&emsp;&emsp;系统异常产生错误时，会将一些遗失的片段放置于此目录下。 8. /opt&emsp;&emsp;给主机额外安装软件所摆放的目录。 9. /proc&emsp;&emsp;此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。 10. /root&emsp;&emsp;系统管理员root的家目录。 11. /sbin、/usr/sbin、/usr/local/sbin&emsp;&emsp;放置系统管理员使用的可执行命令，如fdisk、 shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命 令，一般用户只能”查看”而不能设置和使用。 12. /boot&emsp;&emsp;放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz 13. /tmp&emsp;&emsp;一般用户或正在执行的程序临时存放文件的目录，任何⼈都可以访问，重要数据不可放置在此目录下。 14. /srv&emsp;&emsp;服务启动之后需要访问的数据目录，如 www 服务需要访问的⽹⻚数据存放在 /srv/www 内。 15. /usr&emsp;&emsp;应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放 软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。 16. /var&emsp;&emsp;放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放 的目录，/var/run:程序或服务启动后，其PID存放在该目录下。 二. 路径 相对路径: 从当前位置开始描述的路径为相对路径 绝对路径: 从”/“目录开始描述的路径为绝对路径 三. 点(.)和点点(..) 每个目录下都有点和点点 点表示当前目录 点点表示上一级目录也就是父目录 “/“路径下的点和点点都表示当前目录 四. 访问权限用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读，写，及执行的权限 读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的 权限。 写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删 除、移动目录内文件的权限。 可执行权限（x） 对文件而言，具有执行文件的权限；对目录了来说该用户具有进入 目录的权限。 注: &emsp;&emsp;第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设 备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后 9 个字母分别代表三 组权限：文件所有者、用户组、其他用户拥有的权限。 每一个用户都有它自身的读、写和执行权限。&emsp;&emsp;这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构 成了一个有9种类型的权限组。","categories":[{"name":"linux学习","slug":"linux学习","permalink":"http://yoursite.com/categories/linux学习/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"异常","slug":"exception","date":"2019-12-19T02:50:01.000Z","updated":"2019-12-19T02:51:51.469Z","comments":true,"path":"2019/12/19/exception/","link":"","permalink":"http://yoursite.com/2019/12/19/exception/","excerpt":"初识异常&emsp;&emsp;异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。&emsp;&emsp;Throwable类是Java异常类型的顶级父类, 其又派生出Error类和Exception类; JDK中创建了一些常用的异常类, 当然也可以通过自定义的方式创建异常.Error类以及他的子类的实例，代表了JVM本身的错误。错误不能通过代码处理. Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件,可以被Java异常处理机制使用，是异常处理的核心。","text":"初识异常&emsp;&emsp;异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。&emsp;&emsp;Throwable类是Java异常类型的顶级父类, 其又派生出Error类和Exception类; JDK中创建了一些常用的异常类, 当然也可以通过自定义的方式创建异常.Error类以及他的子类的实例，代表了JVM本身的错误。错误不能通过代码处理. Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件,可以被Java异常处理机制使用，是异常处理的核心。 一. java异常的分类 非检查异常/运行时异常: 编译阶段不会报错, 运行时才出现问题, 如Error, NullPointerException, ArrayIndexOutOfBoundsException等 检查异常/编译时异常: 编译阶段就要求处理, 要么抛出, 要么捕获, 如SQLException, IOException, ClassNotFoundException等 二. 初识异常&emsp;&emsp;异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。 如果没有使用任何异常处理机制, 异常最终会抛给JRE, 导致程序终止 三. 异常处理的基本语法&emsp;&emsp;在编写代码时, 针对编译时异常有两种处理方式(机制), 使用try…catch…finally语句块处理它。或者，在函数签名中使用throws 声明交给函数调用者caller去解决。 try起来: try: 1. try块中放可能发生异常的代码。 2. 如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。 3. 如果发生异常，则尝试去匹配catch块。 catch: 1. 每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7以后可以将多个异常声明在一个catch中。 2. catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 3. 在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 4. 如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，(注)然后到这个函数的外部caller中去匹配异常处理器。 5. 如果try中没有发生异常，则所有的catch块将被忽略。 finally: 1. 无论异常是否发生，异常是否匹配被处理，finally都会执行。 2. finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 注意: 异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。 当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。 良好的习惯: 再try里打开资源, 连接, 再finally里关闭 抛出去: 通过throws关键字实现, 它仅仅是将函数中可能出现的异常向调用者声明, 而自己不具体进行处理, 一方面是方法本身不知道如何处理这种异常, 另一方面是可能让调用者处理更好, 或者说调用者需要为可能发生的异常负责. 四. throw关键字&emsp;&amp;emsp可以通过这个关键字手动显示的抛出一个异常, 其后面必须跟一个异常对象, throw语句必须写在函数中, 执行这个语句的地方就是异常抛出点, 这和JRE自动形成的异常抛出点没有任何差别 五. 自定义异常 实现方式:继承Exception或RuntimeException类 实现规则: 必须包含如下构造函数 一个无参构造 一个带有String参数的构造, 并传递给父类构造 一个带有Throwable参数的构造, 并传递给父类构造 一个带有String参数Throwable参数的构造, 并都传递给父类构造 具体可参考源码的异常定义规则, 如IOException 六. 异常的注意事项 当子类重写父类的带有throws声明的函数时, 其throws声明的异常必须在父类异常的可控范围内, 目的是为了实现多态;比如父类throws了IOException, 子类就必须throws这个异常或这个异常的子类 java中的异常是线程独立的, 这样不会影响到其他线程的执行, 也不至于出了异常一旦没有任何代码处理就导致程序终止 七. 不得其解finally在try语句块中即便有return, break, continue等改变执行流的语句, finally也是会执行的 finally中的return会覆盖try或者catch中的返回值 finally中的return会抑制try或者catch中的异常 finally中的异常会覆盖try或者catch中的异常","categories":[{"name":"exception","slug":"exception","permalink":"http://yoursite.com/categories/exception/"}],"tags":[{"name":"exception","slug":"exception","permalink":"http://yoursite.com/tags/exception/"}]},{"title":"git从github下载内容","slug":"git01","date":"2019-12-19T02:49:01.000Z","updated":"2019-12-19T02:52:32.571Z","comments":true,"path":"2019/12/19/git01/","link":"","permalink":"http://yoursite.com/2019/12/19/git01/","excerpt":"git和github相关操作 右键选择”Git Bash Here”，在弹出的命令框中，输入：","text":"git和github相关操作 右键选择”Git Bash Here”，在弹出的命令框中，输入： ssh-keygen -t rsa -C “your_email@youremail.com“然后会要求确认路径和输入密码，全部直接按回车默认即可。 如果上一步操作成功，则会在c:\\users(你的电脑名).ssh\\下面生成3个文件。用记事本打开id_rsa.pub，然后全选里边的内容。 在网页中登陆你的Git账号，然后打开ssh keys设置网页。可以在设置(setting)中找到SSH keys选项，也可以在登陆成功的前提下直接点击我给出的链接。 点击”Add SSH key”，Title随便填，Key里边粘贴进去在(2)中复制的全部数据。然后点击”Add key”。网页会提示添加成功。 验证是否成功。回到命令框下，输入 ssh -T git@github.com ，如果询问是否继续，输入yes后回车。如果成功，会看到You’ve successfully authenticated, but GitHub does not provide shell access。则表示连接成功。 设置变量。继续在命令框中输入 git config --global user.name &apos;wangzy&apos; git config --global user.email &apos;wangzhiyang199602@163.com&apos; 在网页中手动创建一个repository。比如名称为test，并且选中创建README.md 连接好之后开始下载 8.1 在创建完成后的网页右侧找到 HTTPS clone URL，然后复制。 8.2 打开想要将该仓库下载的目录位置，然后右键选择”Git Bash Here”。输入 git clone http://10.214.168.204:8081/liunan1944/test01.git网址换成你自己的。如果成功，会显示下载了几个文件等信息。 8.3 初始化readme文件，如果已经初始化好了，进行(4)。如果有提示输入username的，建议输入邮箱地址。 8.3.1. git init 8.3.2. touch README.md 8.3.3. git add README.md 8.3.4. git commit -m ‘your infomation’ 8.3.5. git remote add origin https://github.com/…. 8.3.6. git push origin master 问题及解决方法 9.1 github提示Permission denied(public-key) 首先, 清除所有的key-pair ssh-add -D rm -r ~/.ssh 9.2 重新生成ssh密钥对 ssh-keygen -t rsa -C “xxx@xxx.com“","categories":[{"name":"git&github","slug":"git-github","permalink":"http://yoursite.com/categories/git-github/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"Java学习路线","slug":"helloskills","date":"2019-12-19T02:45:01.000Z","updated":"2019-12-19T02:52:12.039Z","comments":true,"path":"2019/12/19/helloskills/","link":"","permalink":"http://yoursite.com/2019/12/19/helloskills/","excerpt":"java技术栈java基础 异常 反射 枚举 注解 继承和多态 泛型 数据结构 内存与JVM 集合 内部类 JDK新特性 设计模式 线程 I/O","text":"java技术栈java基础 异常 反射 枚举 注解 继承和多态 泛型 数据结构 内存与JVM 集合 内部类 JDK新特性 设计模式 线程 I/O J2EE web 主流开发框架 Spring及源码 SpringMVC及源码 Mybatis和JPA Struts和Hibernate(了解) Spring Boot Spring Cloud 前端框架及技术 jQuery JavaScript HTML, CSS(了解) Vue React Ajax EasyUI BootStrap 主流开发技术 JDBC Mysql 分库分表 读写分离 (分布式)事务 Oracle MQ消息队列 Redis POI httpClient Servlet WebService Socket Netty Maven 容器及服务器 tomcat Jetty Nginx Docker Weblogic FastFDS 高并发及处理 定时任务调度 权限校验 原生控制表数据 Shiro Spring Security Canal 同步与异步 测试与日志打印 Junit log4j 编码与加解密 AES MD5 XML DOM Json Restful 项目管理 git github Subversion Linux aop ELK Elasticsearch Lucene Solr LogStash Kibana JSP Zookeeper Dubbo 单点登录 Mycat 监听器 过滤器 拦截器 进阶 区块链 大数据 Python learn a little per day, you will be the winner!","categories":[{"name":"Java技术栈","slug":"Java技术栈","permalink":"http://yoursite.com/categories/Java技术栈/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/技术栈/"}]},{"title":"Linux命令安装Elastic Search","slug":"Linux安装elasticsearc7.1.1","date":"2019-12-19T02:05:06.000Z","updated":"2019-12-19T02:30:53.381Z","comments":true,"path":"2019/12/19/Linux安装elasticsearc7.1.1/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装elasticsearc7.1.1/","excerpt":"Linux(Centos7.6)安装elasticsearch-7.1.1 下载：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.1.1-linux-x86_64.tar.gz","text":"Linux(Centos7.6)安装elasticsearch-7.1.1 下载：https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.1.1-linux-x86_64.tar.gz 上传到/opt文件夹并解压 1tar zxvf elasticsearch-7.1.1-linux-x86_64.tar.gz 在解压后的elasticsearch目录里新建data目录 1mkdir data 修改config/elasticsearch.yml 12345678vim /opt/elasticsearch-7.1.1/config/elasticsearch.ymlcluster.name: my-application #集群名称node.name: node-1 #节点名称path.data: /opt/elasticsearch-7.1.1/data #数据和日志的存储目录path.logs: /opt/elasticsearch-7.1.1/logsnetwork.host: 0.0.0.0 #设置绑定的ip，设置为0.0.0.0以后就可以让任何计算机节点访问到了http.port: 9200 #端口cluster.initial_master_nodes: [\"node-1\"] #设置在集群中的所有节点名称，这个节点名称就是之前所修改的，当然你也可以采用默认的也行，目前是单机，放入一个节点即可 修改内存 12345vim /opt/elasticsearch-7.1.1/config/jvm.options -Xms200m-Xmx200m解决报错：Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c5330000, 986513408, 0) failed; error='Cannot allocate memory' (errno=12) es6.0版本往后的版本不支持root用户启动，需创建用户（es） 123groupadd es #创建用户组useradd es -g es #创建用户chown -R es:es /opt/elasticsearch-7.1.1 #给用户增加权限 解决报各种大小限制问题 1234567891011vim /etc/security/limits.confes soft nofile 65536es hard nofile 65536es soft nproc 4096es hard nproc 4096vim /etc/security/limits.d/20-nproc.confes soft nproc 4096root soft nproc unlimitedvim /etc/sysctl.confvm.max_map_count = 655360sysctl -p #执行查看是否生效 切换到es用户启动es 1./bin/elasticsearch -d(后台启动) 查看进程 1ps -ef | grep elasticsearch","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"elasticsearch7","slug":"elasticsearch7","permalink":"http://yoursite.com/tags/elasticsearch7/"}]},{"title":"Linux命令安装Redis","slug":"Linux安装redis3.2.8","date":"2019-12-19T02:05:05.000Z","updated":"2019-12-19T02:30:43.954Z","comments":true,"path":"2019/12/19/Linux安装redis3.2.8/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装redis3.2.8/","excerpt":"Linux(Centos7.6)安装redis3.2.8 下载 http://download.redis.io/releases","text":"Linux(Centos7.6)安装redis3.2.8 下载 http://download.redis.io/releases 上传到/opt文件夹并解压 1tar -zxvf redis-3.2.8.tar.gz 安装依赖的gcc环境 12rpm -qa | grep gcc #先查询有没有对应的gcc环境yum install gcc make编译安装 12cd /opt/redis-3.2.8make MALLOC=libc &amp; make install 设置redis开机启动 12/opt/redis-3.2.8/utils/install_server.shchkconfig --list #查看开机启动列表 查看redis启动状态 1ps -ef | grep redis 启动和关闭 12service redis_6379 start/redis-server/service redis_6379 restartservice redis_6379 stop redis客户端界面操作 12redis-cli #开启客户端 quit #退出客户端 配置其他信息 12345vim /opt/redis-3.2.8/redis.confprotected-mode no（远程可以访问redis，默认不允许）daemonize yesbind 0.0.0.0(注释绑定端口号)requirepass: 123456 (设置redis密码，默认没有密码) 执行使配置生效 1redis-server /opt/redis-3.2.8/redis.conf","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"Linux命令安装Mysql","slug":"Linux安装mysql5.7.25","date":"2019-12-19T02:05:04.000Z","updated":"2019-12-19T02:30:49.556Z","comments":true,"path":"2019/12/19/Linux安装mysql5.7.25/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装mysql5.7.25/","excerpt":"Linux(Centos7.6)安装mysql-5.7.25 下载 https://downloads.mysql.com/archives/community/","text":"Linux(Centos7.6)安装mysql-5.7.25 下载 https://downloads.mysql.com/archives/community/ 检测是否已经安装mysql 123rpm -qa | grep mysql #如有类似 mysql-libs-5.1.52-1.el6_0.1.x86_64 进行卸载rpm -e mysql-libs-5.1.52-1.el6_0.1.x86_64 #普通删除模式rpm -e --nodeps mysql-libs-5.1.52-1.el6_0.1.x86_64 #强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 检测系统是否有mariadb，若有，同上面步骤卸载 1rpm -qa | grep mariadb 上传文件到服务器 /opt/mysql 解压文件 1tar -zxvf mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz 重命名文件 1mv mysql-5.7.25-linux-glibc2.12-x86_64 mysql-5.7.25 创建mysql用户组和mysql用户(先检查是否存在，若不存在再添加) 1234cat /etc/group | grep mysqlcat /etc/passwd | grep mysqlgroupadd mysqluseradd -r -g mysql mysql #useradd -r 参数表示mysql用户是系统用户，不可用于登录系统 创建data目录 1cd mysql-5.7.25 &amp; mkdir data 将/opt/mysql/mysql-5.7.25的所有者及所属组改为mysql 1chown -R mysql:mysql /opt/mysql/mysql-5.7.25 在/opt/mysql/mysql-5.7.25/support-files目录下创建my_default.cnf 1234567891011[mysqld]sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLESbasedir = /opt/mysql/mysql-5.7.25datadir = /opt/mysql/mysql-5.7.25/dataport = 3306socket = /tmp/mysql.sockcharacter-set-server=utf8log-error = /opt/mysql/mysql-5.7.25/data/mysqld.logpid-file = /opt/mysql/mysql-5.7.25/data/mysqld.pid复制文件到/etc目录下cp support-files/my_default.cnf /etc/my.cnf 初始化mysqld 123cd /opt/mysql/mysql-5.7.25./bin/mysqld --initialize --user=mysql --basedir=/opt/mysql/mysql-5.7.25/ --datadir=/opt/mysql/mysql-5.7.25/data//opt/mysql/mysql-5.7.25/data/mysqld.log #查看日志，获取初始化密码 example : 2019-04-08T06:14:29.790033Z 1 [Note] A temporary password is generated for root@localhost: a8?DQir=T+k+ 把启动脚本放到开机初始化目录 1cp support-files/mysql.server /etc/init.d/mysql 启动 1service mysql start 创建软连接使得在任意目录都可以执行mysql命令, 类似于windows桌面快捷方式 1ln -s /opt/mysql/mysql5.7.25/bin/mysql /usr/bin 登录mysql，密码为初始密码 1mysql -u root -p #Enter password: a8?DQir=T+k+ 修改密码：root 1234mysql&gt; set password=password('root');// 添加数据库访问权限（all）mysql&gt; grant all privileges on *.* to root@'%' identified by 'root';mysql&gt; flush privileges; 退出mysql操作界面 1quit 重启mysql生效 1service mysql restart","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Linux命令安装Git","slug":"Linux安装git2.17.0","date":"2019-12-19T02:05:03.000Z","updated":"2019-12-19T02:30:36.514Z","comments":true,"path":"2019/12/19/Linux安装git2.17.0/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装git2.17.0/","excerpt":"Linux(Centos7.6)安装git2.17.0 下载链接：https://github.com/git/git/archive/v2.17.0.tar.gz","text":"Linux(Centos7.6)安装git2.17.0 下载链接：https://github.com/git/git/archive/v2.17.0.tar.gz 解压： 1tar -zxvf v2.17.0.tar.gz 安装依赖： 1yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker 安装依赖时，yum自动安装了Git，需要卸载旧版本Git 1yum remove git #出现提示输入y即可 编译 1cd git-2.17.0 &amp; make prefix=/usr/local/git all 安装Git至/usr/local/git路径 1make prefix=/usr/local/git install 配置环境变量 123vim /etc/profileexport PATH=$PATH:/usr/local/git/binsource /etc/profile 查看安装的git版本，有版本，安装成功 1git --version","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Linux命令安装Maven","slug":"Linux安装maven3.6","date":"2019-12-19T02:05:02.000Z","updated":"2019-12-19T02:30:57.129Z","comments":true,"path":"2019/12/19/Linux安装maven3.6/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装maven3.6/","excerpt":"Linux(Centos7.6)安装maven3.6 下载文件：http://maven.apache.org/download.cgi","text":"Linux(Centos7.6)安装maven3.6 下载文件：http://maven.apache.org/download.cgi 将文件放到/opt文件夹下面, 若没有上传命令先执行: 1yum -y install lrzsz 解压到当前文件夹 1tar zxvf maven*.tar.gz 添加阿里云镜像 123456789vim /opt/maven/config/settings.xml``` ```xml&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 配置环境变量 1234vim /etc/profileexport MAVEN_HOME=/opt/apache-maven-3.6.3export PATH=$MAVEN_HOME/bin:$PATHsource /etc/profile 校验是否安装成功 1mvn -v\\-version","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"maven3.6","slug":"maven3-6","permalink":"http://yoursite.com/tags/maven3-6/"}]},{"title":"Linux命令安装jdk","slug":"Linux安装jdk1.8","date":"2019-12-19T02:05:01.000Z","updated":"2019-12-19T02:31:07.341Z","comments":true,"path":"2019/12/19/Linux安装jdk1.8/","link":"","permalink":"http://yoursite.com/2019/12/19/Linux安装jdk1.8/","excerpt":"Linux(Centos7.6)安装jdk1.8yum方式安装","text":"Linux(Centos7.6)安装jdk1.8yum方式安装 查看yum源中是否有相关套件 1yum -y list java* 1yum -y install java-1.8.0-openjdk-devel.x86_64 默认安装路径 /usr/lib/jvm 12345vim /etc/profile export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64 export PATH=.:$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar source /etc/profile 校验是否安装成功 1java -version","categories":[{"name":"Linux安装常用软件","slug":"Linux安装常用软件","permalink":"http://yoursite.com/categories/Linux安装常用软件/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"java8","slug":"java8","permalink":"http://yoursite.com/tags/java8/"}]},{"title":"Follow your Heart, don`t run on gasoline","slug":"firstblog","date":"2019-01-03T03:47:33.144Z","updated":"2019-12-19T01:48:37.757Z","comments":true,"path":"2019/01/03/firstblog/","link":"","permalink":"http://yoursite.com/2019/01/03/firstblog/","excerpt":"","text":"Make a little progress every day and make yourself stronger!","categories":[],"tags":[]}]}