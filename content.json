{"meta":{"title":"头铁的bug","subtitle":"straight 2 the top!","description":"If I press the keys in the right order, I can do anything！","author":"Mr.Wang","url":"https://huangpiao.tech"},"pages":[],"posts":[{"title":"发布个人博客简单步骤","slug":"howtodeploy","date":"2019-12-17T03:59:01.994Z","updated":"2019-12-17T05:23:54.693Z","comments":true,"path":"2019/12/17/howtodeploy/","link":"","permalink":"https://huangpiao.tech/2019/12/17/howtodeploy/","excerpt":"","text":"将.md后缀文件添加到/hexo/source/_posts文件夹下 在hexo文件夹下git bash hexo clean hexo server常规发布这下面两个步骤就可以 hexo generate hexo deploy","categories":[],"tags":[]},{"title":"异常","slug":"exception","date":"2019-01-18T09:50:36.035Z","updated":"2019-01-18T09:43:29.973Z","comments":true,"path":"2019/01/18/exception/","link":"","permalink":"https://huangpiao.tech/2019/01/18/exception/","excerpt":"","text":"&emsp;&emsp;异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。&emsp;&emsp;Throwable类是Java异常类型的顶级父类, 其又派生出Error类和Exception类; JDK中创建了一些常用的异常类, 当然也可以通过自定义的方式创建异常.Error类以及他的子类的实例，代表了JVM本身的错误。错误不能通过代码处理. Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件,可以被Java异常处理机制使用，是异常处理的核心。 一. java异常的分类 非检查异常/运行时异常: 编译阶段不会报错, 运行时才出现问题, 如Error, NullPointerException, ArrayIndexOutOfBoundsException等 检查异常/编译时异常: 编译阶段就要求处理, 要么抛出, 要么捕获, 如SQLException, IOException, ClassNotFoundException等 二. 初识异常&emsp;&emsp;异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了异常追踪栈。 如果没有使用任何异常处理机制, 异常最终会抛给JRE, 导致程序终止 三. 异常处理的基本语法&emsp;&emsp;在编写代码时, 针对编译时异常有两种处理方式(机制), 使用try…catch…finally语句块处理它。或者，在函数签名中使用throws 声明交给函数调用者caller去解决。 try起来: try: 1. try块中放可能发生异常的代码。 2. 如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。 3. 如果发生异常，则尝试去匹配catch块。 catch: 1. 每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7以后可以将多个异常声明在一个catch中。 2. catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 3. 在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 4. 如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，(注)然后到这个函数的外部caller中去匹配异常处理器。 5. 如果try中没有发生异常，则所有的catch块将被忽略。 finally: 1. 无论异常是否发生，异常是否匹配被处理，finally都会执行。 2. finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 注意: 异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。 当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。 良好的习惯: 再try里打开资源, 连接, 再finally里关闭 抛出去: 通过throws关键字实现, 它仅仅是将函数中可能出现的异常向调用者声明, 而自己不具体进行处理, 一方面是方法本身不知道如何处理这种异常, 另一方面是可能让调用者处理更好, 或者说调用者需要为可能发生的异常负责. 四. throw关键字&emsp;&amp;emsp可以通过这个关键字手动显示的抛出一个异常, 其后面必须跟一个异常对象, throw语句必须写在函数中, 执行这个语句的地方就是异常抛出点, 这和JRE自动形成的异常抛出点没有任何差别 五. 自定义异常 实现方式:继承Exception或RuntimeException类 实现规则: 必须包含如下构造函数 一个无参构造 一个带有String参数的构造, 并传递给父类构造 一个带有Throwable参数的构造, 并传递给父类构造 一个带有String参数Throwable参数的构造, 并都传递给父类构造 具体可参考源码的异常定义规则, 如IOException 六. 异常的注意事项 当子类重写父类的带有throws声明的函数时, 其throws声明的异常必须在父类异常的可控范围内, 目的是为了实现多态;比如父类throws了IOException, 子类就必须throws这个异常或这个异常的子类 java中的异常是线程独立的, 这样不会影响到其他线程的执行, 也不至于出了异常一旦没有任何代码处理就导致程序终止 七. 不得其解finally在try语句块中即便有return, break, continue等改变执行流的语句, finally也是会执行的 finally中的return会覆盖try或者catch中的返回值 finally中的return会抑制try或者catch中的异常 finally中的异常会覆盖try或者catch中的异常","categories":[],"tags":[]},{"title":"初识Linux","slug":"linux01","date":"2019-01-08T10:15:07.140Z","updated":"2019-01-08T05:45:09.350Z","comments":true,"path":"2019/01/08/linux01/","link":"","permalink":"https://huangpiao.tech/2019/01/08/linux01/","excerpt":"","text":"Linux系统没有盘符的概念, 只有一个根目录”/“, 所有的文件都在这个根目录下面 一. 目录1. “/“&emsp;&emsp;根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西 都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目 录）开始，再进入到home目录。 2. /bin、/usr/bin&emsp;&emsp;可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 3. /dev&emsp;&emsp;存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备， 常用的是挂载光驱 mount /dev/cdrom /mnt。 4. /etc&emsp;&emsp;系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文 件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d等。 5. /home&emsp;&emsp;系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录 下，~表示当前用户的家目录，如: ~edu 表示用户 edu 的家目录。 6. /lib、/usr/lib、/usr/local/lib&emsp;&emsp;系统使用的函数库的目录，程序在执行过程中，需要调 用一些额外的参数时需要函数库的协助。 7. /lost+fount&emsp;&emsp;系统异常产生错误时，会将一些遗失的片段放置于此目录下。 8. /opt&emsp;&emsp;给主机额外安装软件所摆放的目录。 9. /proc&emsp;&emsp;此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。 10. /root&emsp;&emsp;系统管理员root的家目录。 11. /sbin、/usr/sbin、/usr/local/sbin&emsp;&emsp;放置系统管理员使用的可执行命令，如fdisk、 shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命 令，一般用户只能”查看”而不能设置和使用。 12. /boot&emsp;&emsp;放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz 13. /tmp&emsp;&emsp;一般用户或正在执行的程序临时存放文件的目录，任何⼈都可以访问，重要数据不可放置在此目录下。 14. /srv&emsp;&emsp;服务启动之后需要访问的数据目录，如 www 服务需要访问的⽹⻚数据存放在 /srv/www 内。 15. /usr&emsp;&emsp;应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放 软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。 16. /var&emsp;&emsp;放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放 的目录，/var/run:程序或服务启动后，其PID存放在该目录下。 二. 路径 相对路径: 从当前位置开始描述的路径为相对路径 绝对路径: 从”/“目录开始描述的路径为绝对路径 三. 点(.)和点点(..) 每个目录下都有点和点点 点表示当前目录 点点表示上一级目录也就是父目录 “/“路径下的点和点点都表示当前目录 四. 访问权限用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读，写，及执行的权限 读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的 权限。 写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删 除、移动目录内文件的权限。 可执行权限（x） 对文件而言，具有执行文件的权限；对目录了来说该用户具有进入 目录的权限。 注: &emsp;&emsp;第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设 备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件。 后 9 个字母分别代表三 组权限：文件所有者、用户组、其他用户拥有的权限。 每一个用户都有它自身的读、写和执行权限。&emsp;&emsp;这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构 成了一个有9种类型的权限组。","categories":[],"tags":[]},{"title":"Spring Boot","slug":"springboot01","date":"2019-01-08T09:13:53.509Z","updated":"2019-01-08T09:15:32.835Z","comments":true,"path":"2019/01/08/springboot01/","link":"","permalink":"https://huangpiao.tech/2019/01/08/springboot01/","excerpt":"","text":"一. Spring的java配置方式Spring4.x推荐的配置方式，可以完全替代xml配置, 常用注解: @Configuration（作用于类上，相当于一个xml配置文件）； @Bean（作用于方法上，相当于xml配置中的bean标签） @ComponentScan（basePackages = &quot;配置类所在包&quot;） @PropertySource（value=&quot;指定配置文件&quot;，ignoreResourceNotFound = true） @Value（&quot;${key}&quot;）获取配置文件中的值 二. Spring Boot &emsp;&emsp;“习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，无需手动），项目独立运行（运行jar，内嵌Servlet容器），使用它可以不用或只需要很少的Spring配置。 常用注解 @SpringBootApplication（核心注解，用于开启自动配置） 注：自动配置的东西会很多，若想关闭某一项配置 @SpringBootApplication(exclude = {RedisAutoConfiguration.class}) 手动关闭Redis配置 @Configuration @ConditionalOnMissingBean（当容器里没有指定的Bean的情况下创建该对象） @AutoConfigureAfter（*.class）保证在括号内的类实例化完成之后在实例化该类，注解加在类上 注： @ResponseBody：两个作用，首先，将响应结果直接写入HTTP response body中，不会被解析为跳转路径；直接将响应结果以json形式返回； 启动应用通过main方法启动，启动类应在被扫描包的同级或上级包里 全局配置文件 &emsp;&emsp;application.properties 或 application.yml,可以放在resources目录下或者类路径下的/config下，一般是放到resources目录下的 比如：修改tomcat的端口为8088server.port=8088,更多的配置在文件里有参考 Starter pom &emsp;&emsp;个人理解为SpringBoot为我们提供了绝大多数的配置，放置在parent里面，应用的时候，根据具体的业务场景导入相应的依赖也就是Starter pom，就可以实现零配置使用默认配置好的bean，也可以在全局配置里修改默认的配置。 xml配置文件 &emsp;&emsp;可能有一些特殊要求必须使用xml配置，应用注解@ImportResource来加载xml配置 注: &emsp;&emsp;在进行SpringApplication对象实例化的时候会加载META-INF/spring.factories文件，并将该配置文件载入到Spring容器 自定义配置 &emsp;&emsp;如：SpringMVC配置，比如增加一个拦截器，这个时候可以通过继承WebMvcConfigurerAdapter然后重写父类中的方法进行扩展。 事务的配置 &emsp;&emsp;在引入jdbc依赖之后，直接使用@Transactional注解即可，可加在类上，也可以加在方法上 注：内嵌的tomcat是不支持jsp页面的，因此应导入额外的包才能解决 &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;","categories":[],"tags":[]},{"title":"git从github下载内容","slug":"git01","date":"2019-01-08T09:05:02.351Z","updated":"2019-01-08T09:15:01.510Z","comments":true,"path":"2019/01/08/git01/","link":"","permalink":"https://huangpiao.tech/2019/01/08/git01/","excerpt":"","text":"右键选择”Git Bash Here”，在弹出的命令框中，输入： ssh-keygen -t rsa -C “your_email@youremail.com“然后会要求确认路径和输入密码，全部直接按回车默认即可。 如果上一步操作成功，则会在c:\\users(你的电脑名).ssh\\下面生成3个文件。用记事本打开id_rsa.pub，然后全选里边的内容。 在网页中登陆你的Git账号，然后打开ssh keys设置网页。可以在设置(setting)中找到SSH keys选项，也可以在登陆成功的前提下直接点击我给出的链接。 点击”Add SSH key”，Title随便填，Key里边粘贴进去在(2)中复制的全部数据。然后点击”Add key”。网页会提示添加成功。 验证是否成功。回到命令框下，输入 ssh -T git@github.com ，如果询问是否继续，输入yes后回车。如果成功，会看到You’ve successfully authenticated, but GitHub does not provide shell access。则表示连接成功。 设置变量。继续在命令框中输入 git config --global user.name &apos;wangzy&apos; git config --global user.email &apos;wangzhiyang199602@163.com&apos; 在网页中手动创建一个repository。比如名称为test，并且选中创建README.md 连接好之后开始下载 8.1 在创建完成后的网页右侧找到 HTTPS clone URL，然后复制。 8.2 打开想要将该仓库下载的目录位置，然后右键选择”Git Bash Here”。输入 git clone http://10.214.168.204:8081/liunan1944/test01.git网址换成你自己的。如果成功，会显示下载了几个文件等信息。 8.3 初始化readme文件，如果已经初始化好了，进行(4)。如果有提示输入username的，建议输入邮箱地址。 8.3.1. git init 8.3.2. touch README.md 8.3.3. git add README.md 8.3.4. git commit -m ‘your infomation’ 8.3.5. git remote add origin https://github.com/…. 8.3.6. git push origin master 问题及解决方法 9.1 github提示Permission denied(public-key) 首先, 清除所有的key-pair ssh-add -D rm -r ~/.ssh 9.2 重新生成ssh密钥对 ssh-keygen -t rsa -C “xxx@xxx.com“","categories":[],"tags":[]},{"title":"Linux命令","slug":"linux02","date":"2019-01-08T08:05:26.032Z","updated":"2019-01-08T08:44:27.316Z","comments":true,"path":"2019/01/08/linux02/","link":"","permalink":"https://huangpiao.tech/2019/01/08/linux02/","excerpt":"","text":"一. Linux命令格式command 【-options】 【parameter1】… 注: &emsp;&emsp;command：命令名，相应功能的英文单词或单词的缩写 &emsp;&emsp;【-options】：选项，可用来对命令进行控制，也可以省略 &emsp;&emsp;【parameter】：传给命令的参数，可以是0个1个或多个 &emsp;&emsp;[]里的内容是代表可选 二. 查看帮助文档1. command –help2. man(manual)注: &emsp;&emsp;man是linux提供的一个手册，包含了绝大部分的命令以及函数使用说明涉及到功能键及功能： 空格： 显示手册页的下一屏 Enter：一次滚动手册页的一行 b： 回滚一屏 f： 前滚一屏 q： 退出 h： 列出所有功能键 /word：搜索word字符串 三. 历史命令上下键或用history将执行过的命令列举出来 四. Linux命令–文件, 磁盘管理1. ll&amp;ls1.1 文件管理 ls 查看文件信息 注: 以.(点)开头的文件为隐藏文件， 需要用-a参数才能显示-a 显示制定目录下所有子目录与文件，包括隐藏文件-l 以列表方式显示文件的详细信息-h 配合-l以人性化的方式显示文件大小其实一个ll解决一切 1.2 通配符 &emsp;&emsp;*（星号）代表文件名中所有字符,?（问号）代表文件名中任意一个字符,[] (方括号) 将字符组括起来，表示可以匹配字符组中的任意一个。其中‘-（中杠）’表示字符范围. &emsp;&emsp;如： ls [a-f]* 查找并显示a到f范围内的任意一个字符开头的文件\\ (反斜杠) 如果想使通配符作为普通字符用，可以在其前面加上转义字符。另外‘?’和‘*’处于方括号内时不需要使用转义字符就失去了通配符的作用如： ls *a 查找文件名为*a的文件 2. 输出重定向命令：&gt;&emsp;&emsp;将命令执行结果重定向到一个文件， 本应该显示在终端上的内容保存到制定文件中 &emsp;&emsp;如： ls &gt; test.txt(文件若不存在，则创建，若存在则覆盖其中的内容) &emsp;&emsp;注： 可以用cat查看文件的内容，&gt; 输出重定向会覆盖原来的内容， &gt;&gt; 输出重定向则会追加到文件的尾部 3. 分屏显示: more&emsp;&emsp;查看内容时， 在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按空格键可以显示下一页，按q键退出显示，按h键获取帮助。 4. 管道: |&emsp;&emsp;什么是管道，就是一个命令的输出可以通过管道作为另一个命令的输入，通俗一点来讲就是将查寻到或者其他方式得到的数据放到所谓的管道里面，然后对数据继续进行操作 5. 清屏：clear或Ctrl + l6. 切换工作目录： cd&emsp;&emsp;其后可以跟绝对路径，也可以跟相对路径，如果省略目录的话，就默认切换到当前用户的主目录（此时相当于cd~） cd . 切换到当前目录 cd .. 切换到上级目录 cd - 切换到上次所在的目录 注: &emsp;&emsp;Linux所有的目录和文件名大小写敏感，如果路径是从根据径开始的，其前面需要加上‘/’， 而通常进入某个目录里的文件夹，前面不需要加 7. 显示当前路径： pwd8. 创建目录：mkdir参数-p可递归创建目录 &emsp;&emsp;注意新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写的权限 tree： 以目录树的方式显示，显示文件夹层级关系是极好的 9. 删除目录：rmdir10. 删除文件： rmrm可以删除文件和目录。 注意： 文件删除后是不能恢复的，为了防止文件误删，可以在rm后使用-i参数来逐个确认要删除的文件 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归删除目录下的内容，删除文件夹时必须加这个参数 11. 建立链接文件: ln(了解一下)类似与Windows下的快捷方式，分为软连接和硬链接 11.1 软连接：不占用磁盘空间，源文件删除软链接就失效 格式: ln -s 源文件 链接文件 11.2 硬链接: 只能链接普通文件，不能链接目录 格式: ln 源文件 链接文件 注: &emsp;&emsp;建立起的硬链接文件，两个文件占用相同大小的磁盘空间，即使删除了源文件，链接文件还是存在的，因此类似于Windows的快捷方式，软连接是更常见的一种形式； 另外，如果软连接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径 12. 查看或者合并文件内容：cat例如: cat test.txt test2.txt &gt; helloworld.txt 注: &emsp;&emsp;linux的文件不是通过后缀区分的，不一定非是*.txt才是文本文件，通常通过文件的颜色就能区分出是文件或者文件夹 13. 文本搜索: grep是一个强大的文本搜索工具，允许对文本文件进行模式查找。如果找到匹配模式，grep打印包含模式的所有行 13.1 一般格式 grep [-选项] &apos;搜索内容串&apos;文件名 注: &emsp;&emsp;在grep命令中输入字符串参数时，最好用引号括起来，如：grep ‘a’ text.txt,另，linux里是不区分单引号还是双引号的 13.2 常规选项说明 -v: 显示不包含匹配文本的所有行（相当于求反） -n: 显示匹配行及行号 -i: 忽略大小写 注: grep搜索的内容串也可以是正则表达式 14. 查找文件：find&emsp;&emsp;通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件常用语法： 15. 拷贝文件 cp其主要功能是将给出的文件或目录复制到另一个文件或目录中 常用选项: -a：该选项通常在复制目录时使用，它会保留链接，文件属性，并递归地复制目录，简而言之，保持文件的原有属性 -f：已经存在的目标文件而不提示，直接覆盖 -i：交互式复制，在覆盖目标文件之前给出提示要求用户确认 -r：若给出的源文件时目录文件，则cp将递归复制该目录下所有的子目录和文件，目标文件必须为一个目录名 -v：显示拷贝进度 16. 移动文件 mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名 常用选项: -f：禁止交互式操作，即使有覆盖也不给出提示 -i：交互式操作 -v: 显示移动进度 17. 归档管理 tar&emsp;&emsp;tar是Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，亦可以将档案文件解开以恢复数据 17.1 使用格式 tar [参数] 打包文件名 文件 注: tar命令的参数前面既可以使用‘-’，也可以不使用 17.2 常用参数: -z：制定压缩包的格式为：file.tar.gz -c：生成档案文件，创建打包文件 -v：列出归档解档的详细过程，显示进度 -t：列出档案中包含的文件 -x：解开档案文件 -f：指定档案文件名称，f后面一定是.tar文件，因此务必要放选项最后，但其他参数随意 18. 文件压缩与解压缩 gzip&emsp;&emsp;tar与gzip命令结合使用方可实现文件打包，压缩。tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxx.tar.gz 18.1 使用格式: gzip [选项] 被压缩文件 18.2 常用选项: -d：解压 -r：压缩所有子目录（默认不加选项也是压缩） 注：上面的其实没多大卵用，并且麻烦的雅痞，因此在tar命令中增加了一个选项（-z），此时就可以调用gzip从而实现一个压缩的功能，完成先打包后压缩的过程 18.3 压缩用法 tar -zcvf 压缩包包名 文件1 文件2... 注：不同的压缩方式算法不同，因此压缩的速度以及大小均不同，综合起来而言，推荐使用的是tar -zcvf 18.4 解压缩用法 tar -zxvf 压缩包包名 注：默认是解压到当前路径下，要解压到指定目录下可以用选项‘-C’ 19. 文件压缩与解压缩 bzip2&emsp;&emsp;其用法和gzip一样，压缩文件的扩展名一般用：xxx.tar.gz2, 具体实现方式在tar命令中增加一个（-j）选项即可 压缩及解压缩用法： 如： tar -jcvf demo.tar.bz2 *.test tar -jxvf demo.tar.bz2 20. 文件压缩与解压缩：zip 、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。 压缩及解压缩用法： zip [-r] 目标文件（无需扩展名） 源文件 unzip -d 解压后目录文件 压缩文件 21. 查看命令位置 which&emsp;&emsp;如果找到就显示这个命令的路径，找不到就不显示呗，了解一下，没什么卵用 五. Linux命令-系统管理1. 查看当前日历 cal（-y显示整年）2. 显示或设置时间： date2.1 设置时间格式(需要管理员权限) date [MMDDhhmm[[CC]YY][.ss]] +format 注：CC为年前两位yy为年的后两位，前两位的mm为⽉，后两位的mm为分钟，dd为天，hh为 ⼩时，ss为秒。如： date 010203042016.55。 2.2 显示时间格式 date &apos;+%y,%m,%d,%H,%M,%S&apos; 如：date &apos;+%Y/%m/%d&apos; ==&gt;xxxx/xx/xx 注：y/Y效果一样 3. 查看进程信息 ps此命令可以查看进程的详细状况 常用选项（‘-可以省略’）: -a：显示终端上的所有进程，包括其他用户的进程 -u：显示进程的详细状态 -x：显示没有控制终端的进程 -w：显示加宽，以便显示更多的信息 -r：只显示正在运行的进程 4. 动态显示进程 top&emsp;&emsp;用来动态显示运行中的进程，能够再运行之后，在指定的时间间隔更新显示信息，可以通过加选项[-d]来指定显示信息更新的时间间隔 常用按键： M：根据内存使用量排序 P：根据CPU占有率排序 T：根据进程运行时间长短排序 U：根据后面输入的用户名来筛选进程 K：根据后面输入的PID杀死进程 q：退出 h：帮助 5. 终止进程：kill 杀死指定进程号的进程，需要配合ps使用 格式: kill [-signal] pid 注: 其中信号值选项从0到15，9为绝对终止，可以处理一般信号无法终止的进程 6. 关机重启：reboot、shutdown、init如: reboot 重新启动操作系统 shutdown -h now 立刻关机 shutdown -h 20:25 定时关机 shutdown -h +10 系统过十分钟自动关机 init 0 关机 init 6 重启 7. 检测磁盘空间: df&emsp;&emsp;用于检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况 常用选项： -a：显示所有文件系统的磁盘使用情况 -m：以1024字节为单位显示 -t：显示各指定文件系统的磁盘空间使用情况 -T：显示文件系统 8. 检测目录所占磁盘空间：du&emsp;&emsp;用于统计目录或文件所占磁盘空间的大小，该命令的执行结果与df类似，du更测重于磁盘的使用情况 格式: du [选项] 目录或文件名 -a：递归显示指定目录中各文件和子目录中文件占用的数据块 -s：显示指定文件或目录占用的数据块 -b：以字节为单位显示磁盘占用情况 -l：计算所有文件大小，对硬链接文件计算多次 注：在后面加-h可以转换单位，如：du -s build/ -h 显示指定文件占用的数据块，并转换单位 9. 查看或配置网卡信息：ifconfig默认显示所有的网卡信息 &emsp;&emsp;另外，修改网卡的ip地址信息：ifconfig + 网卡名 + 新ip地址，如果权限不足，加sudo，或者通过sudo su切换到root用户操作 10. 测试远程主机联通性：pingping www.baidu.com ping 192.168.1.1 六. Linux命令-用户、权限管理&emsp;&emsp;用户管理包括用户与组账号的管理，无论是由本机或是远程登陆系统，每个系统必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限，root是用于系统的维护和管理的，拥有不受限制的访问权限；再Linux的安装过程中系统会自动创建许多用户账号，这些默认被创建的用户称为‘标准用户’，通常不推荐直接使用root账号登陆系统 1. 查看当前用户：whoami&emsp;&emsp;用户可以使用该命令查看当前系统当前账号的用户名，还可以通过cat /etc/passwd查看系统用户信息 2. 查看登陆用户：who用于查看当前所有登录系统的用户信息，通俗点就是谁登陆了此系统都会显示出来 常用选项: -m或am I ：只显示运行who命令的用户名、登陆终端和登陆时间 -q或--count：只显示用户的登陆账号和登陆用户的数量 -u或--heading：显示列标题 3. 退出登陆用户：exit如果是图形界面，退出当前终端； 如果是使用ssh远程登陆，退出登陆用户； 如果是切换后的登陆用户，退出并返回上一个登陆账号 4. 添加用户账号 useradd使用格式： useradd [选项] 新建用户账号 常用选项: -d：指定用户登陆系统时的主目录，如果不使用该参数，系统就自动再/home目录下面建立与用户名同名目录作为主目录 -m：自动建立目录 -g：指定组名称 注：adduser的命令是指向useradd的一个链接，两个命令的格式完全一样，作用也是一样的； Linux每个用户都有一个主目录，主目录即第一次登陆系统，用户的默认当前目录 （/home/user）； 创建用户的时候，一定要给用户指定一个主目录，因为每一个用户必须要有一个主目录； 用户的主目录一般要放在根目录的home目录下，用户的主目录和用户名是相同的，走默认的即可，前面的约等于扯犊子； 如果创建用户的时候没有指定组名，那么系统也会自动创建一个和用户名一样的组名 一句话，走默认，就够了 如：useradd -d /home/a a -g test 创建一个用户名字叫a，主目录在/home/a, 如果主目录不存在，就自动创建主目录，同时用户属于test组 5. 设置用户密码 passwd&emsp;&emsp;超级用户可以使用passwd命令为普通用户设置或修改用户口令；用户也可以直接使用该命令来修改自己的口令，并且不需要在命令后面使用用户名 6. 删除用户 userdel常用格式： userdel abc : 删除abc用户，但并不会自动删除用户的主目录 userdel -r abc : 删除用户同时删除用户的主目录 7. 切换用户 su&emsp;&emsp;通过此命令切换用户，后面也可以加‘-’中杠，其作用是在切换到对应的用户时会将当前的工作目录自动转换到切换后的用户主目录 注: &emsp;&emsp;在命令前加‘sudo’ 允许系统管理员让普通用户执行全部root权限命令，减少了root用户的登陆和管理时间；（sudo）su 默认切换到root用户；$表示普通用户， #表示root用户 8. 查看有哪些用户组method1: cat /etc/group method2: groupmod + 三次tab键 9. 添加、删除组账号 groupadd groupdel格式: groupadd / groupdel + 组账号 注：一般会报权限不足，应在命令前加sudo 10. 修改用户所在的组 usermod格式: usermod -g 用户组 用户名 注: 查询是否修改成功 cat /etc/group | grep XXX 11. 查看用户在哪些组 groups 12. 为创建的普通用户添加sudo权限sudo usermod -a -G adm 用户名 sudo usermod -a -G sudo 用户名 注：usermod -g 与 -G的区别 -g：用来指定这个用户默认的用户组 -G：一般配合-a来完成向其它组添加 13. 修改文件权限 chmod13.1 字母法： 注： u（user）表示该文件的所有者 g（group）表示与该文件的所有者属于同一组者，也即用户组 o（other） 表示其他以外的用户 a（all） 表示所有，包括以上三者 + 增加权限 - 撤销权限 = 设定权限 13.2 数字法: rwx这些权限是可以用数字来代替的 r：读取权限，数字代号为4 w：写入权限，数字代号为2 x：执行权限，数字代号为1 -：不具备任何权限，数字代号为0 如：执行chmod u=rwx，g=rx, o=r filename等同于：chmod u=7,g=5,o=4 filename也等同于 chmod 751 filename； 另，若想递归所有目录加上相同权限，需加上参数‘-R’ 如：chmod 777 test/ -R 可递归test目录下所有文件并加777权限 14. 修改文件所有者 chown格式： chown + 文件所有者 + 文件名 15. 修改文件所属组 chgrp格式：chgrp + 文件所属组 + 文件名 七. Vim编辑器及相关命令&emsp;&emsp;vi（Visual interface）,即可视化界面，分为三种基本工作模式：命令模式、文本输入模式、末行模式vim是从vi发展出来的一个文本编辑器，下面为它的基础操作 1. 进入插入模式:i：插入光标前一个字符 I：插入行首 a：插入光标后一个字符 A：插入行末 o：向下新开一行，插入行首 O：向上新开一行，插入行首 2. 进入命令模式：ESC：会从插入模式或末行模式进入命令模式 3. 移动光标：h: 左移 j: 下移 k: 上移 l: 右移 M: 光标移动到中间行 L: 光标移动到屏幕最后一行行首 G: 移动到指定行,行号 -G w: 向后一次移动一个字 b: 向前一次移动一个字 {: 按段移动,上移 }: 按段移动,下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏 gg: 光标移动文件开头 G: 光标移动到文件末尾 4. 删除命令x: 删除光标后一个字符,相当于 Del X: 删除光标前一个字符,相当于 Backspace dd: 删除光标所在行,n dd 删除指定的行数 D: 删除光标后本行所有内容,包含光标所在字符 d0: 删除光标前本行所有内容,不包含光标所在字符 dw: 删除光标开始位置的字,包含光标所在字符 5. 撤销命令u：一步步撤销 Ctrl - r：反撤销 6. 重复命令.(点): 重复上一次操作的命令 7. 文本行移动&gt;&gt;: 文本行右移 &lt;&lt;: 文本行左移 8. 复制粘贴yy：复制当前行，n yy 复制n行 p：在光标所在位置向下开辟一行并粘贴 9. 可视模式v：按字符移动，选中文本 V：按行移动，选中文本可视模式可以配合d，y，&gt;&gt;, &lt;&lt;实现对文本块的删除，复制以及左右移动 10. 替换操作r：替换当前字符 R：替换当前行光标后的字符 11. 查找命令/：str查找 n：下一个 N：上一个 12. 替换命令如：把abc全部替换成123 末行模式下，将当前文件中的所有abc替换成123 ：%s/abc/123/g 末行模式下，将第一行至第10行之间的abc替换成123 ：1，10s/abc/123/g 注: 若在vim里执行shell下命令，可以通过在末行模式里输入！，后面跟命令即可 八. 分屏操作(进阶)1. 常用分屏操作:sp：上下分屏，后可跟文件名 vsp：左右分屏，后可跟文件名 Ctrl+w+w：在多个窗口切换 2. 启动分屏:2.1 使用大写O选项进行垂直分屏 格式：vim -On file1 file2 ... 2.2 使用小写o参数进行水平分屏 格式：vim -on file1 file2 ... 注：n是数字，表示分屏的数量，要保证n大于等于文件的个数 3. 关闭分屏:3.1 关闭当前窗口 Ctrl + w c 3.2 关闭当前窗口，如果只剩最后一个，则退出vim Ctrl + w a 4. 编辑中分屏4.1 上下分割当前打开的文件 Ctrl+w s 4.2 上下分割，并打开一个新的文件 ：sp filename 4.3 左右分割当前打开的文件 ctrl+w v 4.4 左右分割，并打开一个新的文件 ：vsp filename 5. 分屏编辑中光标的移动&emsp;&emsp;vi中的光标键是h，j，k，l，要想在各个屏之间切换，只需要先按一下Ctrl+w 把光标移动到上边的屏 ctrl + w k 把光标移动到下一个屏 ctrl + w w 6. 移动分屏如: 向上移动：ctrl+w K(大写，其他参考光标键) 7. 屏幕尺寸7.1 增加高度 ctrl+w + 7.2 减少高度 ctrl+w - 7.3 让所有的屏高度一致 ctrl+w = 7.4 左加宽度 ctrl+w &gt; 7.5 右加宽度 ctrl+w &lt; 7.6 右增加n宽(如: n = 30) ctrl + w n &lt;","categories":[],"tags":[]},{"title":"Java学习路线","slug":"helloskills","date":"2019-01-04T02:06:23.203Z","updated":"2019-01-04T02:15:46.561Z","comments":true,"path":"2019/01/04/helloskills/","link":"","permalink":"https://huangpiao.tech/2019/01/04/helloskills/","excerpt":"","text":"java基础 异常 反射 枚举 注解 继承和多态 泛型 数据结构 内存与JVM 集合 内部类 JDK新特性 设计模式 线程 I/O J2EE web 主流开发框架 Spring及源码 SpringMVC及源码 Mybatis和JPA Struts和Hibernate(了解) Spring Boot Spring Cloud 前端框架及技术 jQuery JavaScript HTML, CSS(了解) Vue React Ajax EasyUI BootStrap 主流开发技术 JDBC Mysql 分库分表 读写分离 (分布式)事务 Oracle MQ消息队列 Redis POI httpClient Servlet WebService Socket Netty Maven 容器及服务器 tomcat Jetty Nginx Docker Weblogic FastFDS 高并发及处理 定时任务调度 权限校验 原生控制表数据 Shiro Spring Security Canal 同步与异步 测试与日志打印 Junit log4j 编码与加解密 AES MD5 XML DOM Json Restful 项目管理 git github Subversion Linux aop ELK Elasticsearch Lucene Solr LogStash Kibana JSP Zookeeper Dubbo 单点登录 Mycat 监听器 过滤器 拦截器 进阶 区块链 大数据 Python learn a little per day, you will be the winner!","categories":[],"tags":[]},{"title":"Follow your Heart, don`t run on gasoline","slug":"firstblog","date":"2019-01-03T03:47:33.144Z","updated":"2019-01-04T08:05:44.365Z","comments":true,"path":"2019/01/03/firstblog/","link":"","permalink":"https://huangpiao.tech/2019/01/03/firstblog/","excerpt":"","text":"&emsp;&emsp;做一个有思想, 会思考的人真的很重要; 所谓的有思想, 就是时刻清楚什么事该做, 什么事情不该做, 现在应该干什么, 现在又不应该该干什么, 不要被自己盲目的灵魂支配着, 过着浑浑噩噩的生活, 像机器一样碌碌无为的活着! 所谓会思考, 它是一种能力, 也是一种习惯, 这种习惯是经过不停地锻炼养成的, 也必然是通过自己独立的不断反复的尝试, 实践练就出来的, 它也无疑是作为一个程序员最宝贵的东西, 它能给你带来一切!&emsp;&emsp;另外你可能拥有一个很low但是可能会有帮助的特质, 就是头铁, 东西上手慢不要紧, 主要是不上手, 刚开始可能会很难, 一窍不通, 那就硬着头皮去钻, 去啃, 总会有成效的, 哪怕成效低的自己都看不到, 潜移默化着最终必然会成为自己都不认识自己, 没错, 这时候你的头铁已经变成了所谓的会思考!&emsp;&emsp;别每次光说不练, 往往都是坚持个几天, 几星期, 当时还暗自悔恨, 如果早…那该多好, 不久之后, 就…样吧, 坚持真的太难了! 我是咸鱼我怕谁, 我翻身之后可能更咸我骄傲了吗? 其实也没必要跟高中一样, 就只知道下功夫, 生活中的八成都耗在学习上, 现在是一个成年人, 肯定有自己想做的事或者是该做的事, 合理安排自己的业余时间也是成熟的一种表现吧, 在有空的时候就多看看书, 看看资料, 多学一点总是好的, 看看自己身边的小伙伴一个个都起飞了, 你还在吭哧吭哧呢. 又不需要也不可能把时间都抽出来学东西, 每天哪怕抽出来两个小时, 一个小时, 甚至半个小时都是可能的呀, 周末的时候也不能说不放松, 稍微抽一点时间看看东西, 再说了, 你周末那叫放松呀, 整天他妈比上班还累呢, 真的, 学习就当是休息了, 地铁上, 睡觉前, 需要学的, 看的东西还好多, 再业余的时间抽空丰富自己, 充实自己, 做个有思想的人, 这样, 成功就离你不远了, 要做碌碌无为空虚寂寞的你, 还是做事业有成, 空虚寂寞的你, 这是个问题!&emsp;&emsp;没错, 就是从现在开始, 已经开始了不知道多少次, 给自己一个目标, 重新活给自己看, 简单的改变一下自己之前的生活方式, 给自己一个相对较好的另一种生活, 希望这次, 你是认真的.","categories":[],"tags":[]}]}